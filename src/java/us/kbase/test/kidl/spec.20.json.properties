{
  "Tree" : [ [ {
    "!" : "Bio::KBase::KIDL::KBT::DefineModule",
    "annotations" : {
      "unknown_annotations" : { }
    },
    "comment" : "Phylogenetic Tree and Multiple Sequence Alignment Services\n\nThis service provides a set of methods for querying, manipulating, and analyzing multiple\nsequence alignments and phylogenetic trees.\n\nAuthors\n---------\nMichael Sneddon, LBL (mwsneddon@lbl.gov)\nFangfang Xia, ANL (fangfang.xia@gmail.com)\nMatt Henderson, LBL (mhenderson@lbl.gov)",
    "module_components" : [ {
      "!" : "Bio::KBase::KIDL::KBT::Typedef",
      "alias_type" : {
        "!" : "Bio::KBase::KIDL::KBT::Scalar",
        "annotations" : { },
        "scalar_type" : "int"
      },
      "annotations" : {
        "metadata" : { },
        "searchable_ws_subset" : { },
        "unknown_annotations" : { }
      },
      "comment" : "indicates true or false values, false <= 0, true >=1",
      "module" : "Tree",
      "name" : "bool"
    }, {
      "!" : "Bio::KBase::KIDL::KBT::Typedef",
      "alias_type" : {
        "!" : "Bio::KBase::KIDL::KBT::Scalar",
        "annotations" : { },
        "scalar_type" : "string"
      },
      "annotations" : {
        "metadata" : { },
        "searchable_ws_subset" : { },
        "unknown_annotations" : { }
      },
      "comment" : "time in units of number of seconds since the epoch",
      "module" : "Tree",
      "name" : "timestamp"
    }, {
      "!" : "Bio::KBase::KIDL::KBT::Typedef",
      "alias_type" : {
        "!" : "Bio::KBase::KIDL::KBT::Scalar",
        "annotations" : { },
        "scalar_type" : "int"
      },
      "annotations" : {
        "metadata" : { },
        "searchable_ws_subset" : { },
        "unknown_annotations" : { }
      },
      "comment" : "integer number indicating a 1-based position in an amino acid / nucleotide sequence",
      "module" : "Tree",
      "name" : "position"
    }, {
      "!" : "Bio::KBase::KIDL::KBT::Typedef",
      "alias_type" : {
        "!" : "Bio::KBase::KIDL::KBT::Scalar",
        "annotations" : { },
        "scalar_type" : "string"
      },
      "annotations" : {
        "metadata" : { },
        "searchable_ws_subset" : { },
        "unknown_annotations" : { }
      },
      "comment" : "A KBase ID is a string starting with the characters \"kb|\".  KBase IDs are typed. The types are\ndesignated using a short string. For instance,\" g\" denotes a genome, \"tree\" denotes a Tree, and\n\"aln\" denotes a sequence alignment. KBase IDs may be hierarchical.  For example, if a KBase genome\nidentifier is \"kb|g.1234\", a protein encoding gene within that genome may be represented as\n\"kb|g.1234.peg.771\".",
      "module" : "Tree",
      "name" : "kbase_id"
    }, {
      "!" : "Bio::KBase::KIDL::KBT::Typedef",
      "alias_type" : {
        "!" : "Bio::KBase::KIDL::KBT::Scalar",
        "annotations" : { },
        "scalar_type" : "string"
      },
      "annotations" : {
        "metadata" : { },
        "searchable_ws_subset" : { },
        "unknown_annotations" : { }
      },
      "comment" : "A string representation of a phylogenetic tree.  The format/syntax of the string is\nspecified by using one of the available typedefs declaring a particular format, such as 'newick_tree',\n'phyloXML_tree' or 'json_tree'.  When a format is not explictily specified, it is possible to return\ntrees in different formats depending on addtional parameters. Regardless of format, all leaf nodes\nin trees built from MSAs are indexed to a specific MSA row.  You can use the appropriate functionality\nof the API to replace these IDs with other KBase Ids instead. Internal nodes may or may not be named.\nNodes, depending on the format, may also be annotated with structured data such as bootstrap values and\ndistances.",
      "module" : "Tree",
      "name" : "tree"
    }, {
      "!" : "Bio::KBase::KIDL::KBT::Typedef",
      "alias_type" : {
        "!" : "Bio::KBase::KIDL::KBT::Typedef",
        "alias_type" : {
          "!" : "Bio::KBase::KIDL::KBT::Scalar",
          "annotations" : { },
          "scalar_type" : "string"
        },
        "annotations" : {
          "metadata" : { },
          "searchable_ws_subset" : { },
          "unknown_annotations" : { }
        },
        "comment" : "A string representation of a phylogenetic tree.  The format/syntax of the string is\nspecified by using one of the available typedefs declaring a particular format, such as 'newick_tree',\n'phyloXML_tree' or 'json_tree'.  When a format is not explictily specified, it is possible to return\ntrees in different formats depending on addtional parameters. Regardless of format, all leaf nodes\nin trees built from MSAs are indexed to a specific MSA row.  You can use the appropriate functionality\nof the API to replace these IDs with other KBase Ids instead. Internal nodes may or may not be named.\nNodes, depending on the format, may also be annotated with structured data such as bootstrap values and\ndistances.",
        "module" : "Tree",
        "name" : "tree"
      },
      "annotations" : {
        "metadata" : { },
        "searchable_ws_subset" : { },
        "unknown_annotations" : { }
      },
      "comment" : "Trees are represented in KBase by default in newick format (http://en.wikipedia.org/wiki/Newick_format)\nand are returned to you in this format by default.",
      "module" : "Tree",
      "name" : "newick_tree"
    }, {
      "!" : "Bio::KBase::KIDL::KBT::Typedef",
      "alias_type" : {
        "!" : "Bio::KBase::KIDL::KBT::Typedef",
        "alias_type" : {
          "!" : "Bio::KBase::KIDL::KBT::Scalar",
          "annotations" : { },
          "scalar_type" : "string"
        },
        "annotations" : {
          "metadata" : { },
          "searchable_ws_subset" : { },
          "unknown_annotations" : { }
        },
        "comment" : "A string representation of a phylogenetic tree.  The format/syntax of the string is\nspecified by using one of the available typedefs declaring a particular format, such as 'newick_tree',\n'phyloXML_tree' or 'json_tree'.  When a format is not explictily specified, it is possible to return\ntrees in different formats depending on addtional parameters. Regardless of format, all leaf nodes\nin trees built from MSAs are indexed to a specific MSA row.  You can use the appropriate functionality\nof the API to replace these IDs with other KBase Ids instead. Internal nodes may or may not be named.\nNodes, depending on the format, may also be annotated with structured data such as bootstrap values and\ndistances.",
        "module" : "Tree",
        "name" : "tree"
      },
      "annotations" : {
        "metadata" : { },
        "searchable_ws_subset" : { },
        "unknown_annotations" : { }
      },
      "comment" : "Trees are represented in KBase by default in newick format (http://en.wikipedia.org/wiki/Newick_format),\nbut can optionally be converted to the more verbose phyloXML format, which is useful for compatibility or\nwhen additional information/annotations decorate the tree.",
      "module" : "Tree",
      "name" : "phyloXML_tree"
    }, {
      "!" : "Bio::KBase::KIDL::KBT::Typedef",
      "alias_type" : {
        "!" : "Bio::KBase::KIDL::KBT::Typedef",
        "alias_type" : {
          "!" : "Bio::KBase::KIDL::KBT::Scalar",
          "annotations" : { },
          "scalar_type" : "string"
        },
        "annotations" : {
          "metadata" : { },
          "searchable_ws_subset" : { },
          "unknown_annotations" : { }
        },
        "comment" : "A string representation of a phylogenetic tree.  The format/syntax of the string is\nspecified by using one of the available typedefs declaring a particular format, such as 'newick_tree',\n'phyloXML_tree' or 'json_tree'.  When a format is not explictily specified, it is possible to return\ntrees in different formats depending on addtional parameters. Regardless of format, all leaf nodes\nin trees built from MSAs are indexed to a specific MSA row.  You can use the appropriate functionality\nof the API to replace these IDs with other KBase Ids instead. Internal nodes may or may not be named.\nNodes, depending on the format, may also be annotated with structured data such as bootstrap values and\ndistances.",
        "module" : "Tree",
        "name" : "tree"
      },
      "annotations" : {
        "metadata" : { },
        "searchable_ws_subset" : { },
        "unknown_annotations" : { }
      },
      "comment" : "Trees are represented in KBase by default in newick format (http://en.wikipedia.org/wiki/Newick_format),\nbut can optionally be converted to JSON format where the structure of the tree matches the structure of\nthe JSON object.  This is useful when interacting with the tree in JavaScript, for instance.",
      "module" : "Tree",
      "name" : "json_tree"
    }, {
      "!" : "Bio::KBase::KIDL::KBT::Typedef",
      "alias_type" : {
        "!" : "Bio::KBase::KIDL::KBT::Scalar",
        "annotations" : { },
        "scalar_type" : "string"
      },
      "annotations" : {
        "metadata" : { },
        "searchable_ws_subset" : { },
        "unknown_annotations" : { }
      },
      "comment" : "String representation of a sequence alignment, the format of which may be different depending on\ninput options for retrieving the alignment.",
      "module" : "Tree",
      "name" : "alignment"
    }, {
      "!" : "Bio::KBase::KIDL::KBT::Typedef",
      "alias_type" : {
        "!" : "Bio::KBase::KIDL::KBT::Scalar",
        "annotations" : { },
        "scalar_type" : "string"
      },
      "annotations" : {
        "metadata" : { },
        "searchable_ws_subset" : { },
        "unknown_annotations" : { }
      },
      "comment" : "String representation of a sequence or set of sequences in FASTA format.  The precise alphabet used is\nnot yet specified, but will be similar to sequences stored in KBase with '-' to denote gaps in alignments.",
      "module" : "Tree",
      "name" : "fasta"
    }, {
      "!" : "Bio::KBase::KIDL::KBT::Typedef",
      "alias_type" : {
        "!" : "Bio::KBase::KIDL::KBT::Typedef",
        "alias_type" : {
          "!" : "Bio::KBase::KIDL::KBT::Scalar",
          "annotations" : { },
          "scalar_type" : "string"
        },
        "annotations" : {
          "metadata" : { },
          "searchable_ws_subset" : { },
          "unknown_annotations" : { }
        },
        "comment" : "String representation of a sequence or set of sequences in FASTA format.  The precise alphabet used is\nnot yet specified, but will be similar to sequences stored in KBase with '-' to denote gaps in alignments.",
        "module" : "Tree",
        "name" : "fasta"
      },
      "annotations" : {
        "metadata" : { },
        "searchable_ws_subset" : { },
        "unknown_annotations" : { }
      },
      "comment" : "String representation of an alignment in FASTA format.  The precise alphabet and syntax of the alignment\nstring is not yet specified, but will be similar to sequences stored in KBase  with '-' to denote gaps in\nalignments.",
      "module" : "Tree",
      "name" : "fasta_alignment"
    }, {
      "!" : "Bio::KBase::KIDL::KBT::Typedef",
      "alias_type" : {
        "!" : "Bio::KBase::KIDL::KBT::Scalar",
        "annotations" : { },
        "scalar_type" : "string"
      },
      "annotations" : {
        "metadata" : { },
        "searchable_ws_subset" : { },
        "unknown_annotations" : { }
      },
      "comment" : "The string representation of the parsed node name (may be a kbase_id, but does not have to be).  Note that this\nis not the full, raw label in a newick_tree (which may include comments).",
      "module" : "Tree",
      "name" : "node_name"
    }, {
      "!" : "Bio::KBase::KIDL::KBT::Typedef",
      "alias_type" : {
        "!" : "Bio::KBase::KIDL::KBT::Scalar",
        "annotations" : { },
        "scalar_type" : "string"
      },
      "annotations" : {
        "metadata" : { },
        "searchable_ws_subset" : { },
        "unknown_annotations" : { }
      },
      "comment" : "String in HTML format, used in the KBase Tree library for returning rendered trees.",
      "module" : "Tree",
      "name" : "html_file"
    }, {
      "!" : "Bio::KBase::KIDL::KBT::Typedef",
      "alias_type" : {
        "!" : "Bio::KBase::KIDL::KBT::Struct",
        "annotations" : {
          "metadata" : { },
          "searchable_ws_subset" : { }
        },
        "comment" : "Meta data associated with a tree.\n\n    kbase_id alignment_id - if this tree was built from an alignment, this provides that alignment id\n    string type - the type of tree; possible values currently are \"sequence_alignment\" and \"genome\" for trees\n                  either built from a sequence alignment, or imported directly indexed to genomes.\n    string status - set to 'active' if this is the latest built tree for a particular gene family\n    timestamp date_created - time at which the tree was built/loaded in seconds since the epoch\n    string tree_contruction_method - the name of the software used to construct the tree\n    string tree_construction_parameters - any non-default parameters of the tree construction method\n    string tree_protocol - simple free-form text which may provide additional details of how the tree was built\n    int node_count - total number of nodes in the tree\n    int leaf_count - total number of leaf nodes in the tree (generally this cooresponds to the number of sequences)\n    string source_db - the source database where this tree originated, if one exists\n    string source_id - the id of this tree in an external database, if one exists",
        "items" : [ {
          "!" : "Bio::KBase::KIDL::KBT::StructItem",
          "item_type" : {
            "!" : "Bio::KBase::KIDL::KBT::Typedef",
            "alias_type" : {
              "!" : "Bio::KBase::KIDL::KBT::Scalar",
              "annotations" : { },
              "scalar_type" : "string"
            },
            "annotations" : {
              "metadata" : { },
              "searchable_ws_subset" : { },
              "unknown_annotations" : { }
            },
            "comment" : "A KBase ID is a string starting with the characters \"kb|\".  KBase IDs are typed. The types are\ndesignated using a short string. For instance,\" g\" denotes a genome, \"tree\" denotes a Tree, and\n\"aln\" denotes a sequence alignment. KBase IDs may be hierarchical.  For example, if a KBase genome\nidentifier is \"kb|g.1234\", a protein encoding gene within that genome may be represented as\n\"kb|g.1234.peg.771\".",
            "module" : "Tree",
            "name" : "kbase_id"
          },
          "name" : "alignment_id",
          "nullable" : "0"
        }, {
          "!" : "Bio::KBase::KIDL::KBT::StructItem",
          "item_type" : {
            "!" : "Bio::KBase::KIDL::KBT::Scalar",
            "annotations" : { },
            "scalar_type" : "string"
          },
          "name" : "type",
          "nullable" : "0"
        }, {
          "!" : "Bio::KBase::KIDL::KBT::StructItem",
          "item_type" : {
            "!" : "Bio::KBase::KIDL::KBT::Scalar",
            "annotations" : { },
            "scalar_type" : "string"
          },
          "name" : "status",
          "nullable" : "0"
        }, {
          "!" : "Bio::KBase::KIDL::KBT::StructItem",
          "item_type" : {
            "!" : "Bio::KBase::KIDL::KBT::Typedef",
            "alias_type" : {
              "!" : "Bio::KBase::KIDL::KBT::Scalar",
              "annotations" : { },
              "scalar_type" : "string"
            },
            "annotations" : {
              "metadata" : { },
              "searchable_ws_subset" : { },
              "unknown_annotations" : { }
            },
            "comment" : "time in units of number of seconds since the epoch",
            "module" : "Tree",
            "name" : "timestamp"
          },
          "name" : "date_created",
          "nullable" : "0"
        }, {
          "!" : "Bio::KBase::KIDL::KBT::StructItem",
          "item_type" : {
            "!" : "Bio::KBase::KIDL::KBT::Scalar",
            "annotations" : { },
            "scalar_type" : "string"
          },
          "name" : "tree_contruction_method",
          "nullable" : "0"
        }, {
          "!" : "Bio::KBase::KIDL::KBT::StructItem",
          "item_type" : {
            "!" : "Bio::KBase::KIDL::KBT::Scalar",
            "annotations" : { },
            "scalar_type" : "string"
          },
          "name" : "tree_construction_parameters",
          "nullable" : "0"
        }, {
          "!" : "Bio::KBase::KIDL::KBT::StructItem",
          "item_type" : {
            "!" : "Bio::KBase::KIDL::KBT::Scalar",
            "annotations" : { },
            "scalar_type" : "string"
          },
          "name" : "tree_protocol",
          "nullable" : "0"
        }, {
          "!" : "Bio::KBase::KIDL::KBT::StructItem",
          "item_type" : {
            "!" : "Bio::KBase::KIDL::KBT::Scalar",
            "annotations" : { },
            "scalar_type" : "int"
          },
          "name" : "node_count",
          "nullable" : "0"
        }, {
          "!" : "Bio::KBase::KIDL::KBT::StructItem",
          "item_type" : {
            "!" : "Bio::KBase::KIDL::KBT::Scalar",
            "annotations" : { },
            "scalar_type" : "int"
          },
          "name" : "leaf_count",
          "nullable" : "0"
        }, {
          "!" : "Bio::KBase::KIDL::KBT::StructItem",
          "item_type" : {
            "!" : "Bio::KBase::KIDL::KBT::Scalar",
            "annotations" : { },
            "scalar_type" : "string"
          },
          "name" : "source_db",
          "nullable" : "0"
        }, {
          "!" : "Bio::KBase::KIDL::KBT::StructItem",
          "item_type" : {
            "!" : "Bio::KBase::KIDL::KBT::Scalar",
            "annotations" : { },
            "scalar_type" : "string"
          },
          "name" : "source_id",
          "nullable" : "0"
        } ],
        "module" : "Tree",
        "name" : "tree_meta_data"
      },
      "annotations" : {
        "metadata" : { },
        "searchable_ws_subset" : { },
        "unknown_annotations" : { }
      },
      "comment" : "Meta data associated with a tree.\n\n    kbase_id alignment_id - if this tree was built from an alignment, this provides that alignment id\n    string type - the type of tree; possible values currently are \"sequence_alignment\" and \"genome\" for trees\n                  either built from a sequence alignment, or imported directly indexed to genomes.\n    string status - set to 'active' if this is the latest built tree for a particular gene family\n    timestamp date_created - time at which the tree was built/loaded in seconds since the epoch\n    string tree_contruction_method - the name of the software used to construct the tree\n    string tree_construction_parameters - any non-default parameters of the tree construction method\n    string tree_protocol - simple free-form text which may provide additional details of how the tree was built\n    int node_count - total number of nodes in the tree\n    int leaf_count - total number of leaf nodes in the tree (generally this cooresponds to the number of sequences)\n    string source_db - the source database where this tree originated, if one exists\n    string source_id - the id of this tree in an external database, if one exists",
      "module" : "Tree",
      "name" : "tree_meta_data"
    }, {
      "!" : "Bio::KBase::KIDL::KBT::Typedef",
      "alias_type" : {
        "!" : "Bio::KBase::KIDL::KBT::Struct",
        "annotations" : {
          "metadata" : { },
          "searchable_ws_subset" : { }
        },
        "comment" : "Meta data associated with an alignment.\n\n    list<kbase_id> tree_ids - the set of trees that were built from this alignment\n    string status - set to 'active' if this is the latest alignment for a particular set of sequences\n    string sequence_type - indicates what type of sequence is aligned (e.g. protein vs. dna)\n    bool is_concatenation - true if the alignment is based on the concatenation of multiple non-contiguous\n                            sequences, false if each row cooresponds to exactly one sequence (possibly with gaps)\n    timestamp date_created - time at which the alignment was built/loaded in seconds since the epoch\n    int n_rows - number of rows in the alignment\n    int n_cols - number of columns in the alignment\n    string alignment_construction_method - the name of the software tool used to build the alignment\n    string alignment_construction_parameters - set of non-default parameters used to construct the alignment\n    string alignment_protocol - simple free-form text which may provide additional details of how the alignment was built\n    string source_db - the source database where this alignment originated, if one exists\n    string source_id - the id of this alignment in an external database, if one exists",
        "items" : [ {
          "!" : "Bio::KBase::KIDL::KBT::StructItem",
          "item_type" : {
            "!" : "Bio::KBase::KIDL::KBT::List",
            "annotations" : { },
            "element_type" : {
              "!" : "Bio::KBase::KIDL::KBT::Typedef",
              "alias_type" : {
                "!" : "Bio::KBase::KIDL::KBT::Scalar",
                "annotations" : { },
                "scalar_type" : "string"
              },
              "annotations" : {
                "metadata" : { },
                "searchable_ws_subset" : { },
                "unknown_annotations" : { }
              },
              "comment" : "A KBase ID is a string starting with the characters \"kb|\".  KBase IDs are typed. The types are\ndesignated using a short string. For instance,\" g\" denotes a genome, \"tree\" denotes a Tree, and\n\"aln\" denotes a sequence alignment. KBase IDs may be hierarchical.  For example, if a KBase genome\nidentifier is \"kb|g.1234\", a protein encoding gene within that genome may be represented as\n\"kb|g.1234.peg.771\".",
              "module" : "Tree",
              "name" : "kbase_id"
            }
          },
          "name" : "tree_ids",
          "nullable" : "0"
        }, {
          "!" : "Bio::KBase::KIDL::KBT::StructItem",
          "item_type" : {
            "!" : "Bio::KBase::KIDL::KBT::Scalar",
            "annotations" : { },
            "scalar_type" : "string"
          },
          "name" : "status",
          "nullable" : "0"
        }, {
          "!" : "Bio::KBase::KIDL::KBT::StructItem",
          "item_type" : {
            "!" : "Bio::KBase::KIDL::KBT::Scalar",
            "annotations" : { },
            "scalar_type" : "string"
          },
          "name" : "sequence_type",
          "nullable" : "0"
        }, {
          "!" : "Bio::KBase::KIDL::KBT::StructItem",
          "item_type" : {
            "!" : "Bio::KBase::KIDL::KBT::Scalar",
            "annotations" : { },
            "scalar_type" : "string"
          },
          "name" : "is_concatenation",
          "nullable" : "0"
        }, {
          "!" : "Bio::KBase::KIDL::KBT::StructItem",
          "item_type" : {
            "!" : "Bio::KBase::KIDL::KBT::Typedef",
            "alias_type" : {
              "!" : "Bio::KBase::KIDL::KBT::Scalar",
              "annotations" : { },
              "scalar_type" : "string"
            },
            "annotations" : {
              "metadata" : { },
              "searchable_ws_subset" : { },
              "unknown_annotations" : { }
            },
            "comment" : "time in units of number of seconds since the epoch",
            "module" : "Tree",
            "name" : "timestamp"
          },
          "name" : "date_created",
          "nullable" : "0"
        }, {
          "!" : "Bio::KBase::KIDL::KBT::StructItem",
          "item_type" : {
            "!" : "Bio::KBase::KIDL::KBT::Scalar",
            "annotations" : { },
            "scalar_type" : "int"
          },
          "name" : "n_rows",
          "nullable" : "0"
        }, {
          "!" : "Bio::KBase::KIDL::KBT::StructItem",
          "item_type" : {
            "!" : "Bio::KBase::KIDL::KBT::Scalar",
            "annotations" : { },
            "scalar_type" : "int"
          },
          "name" : "n_cols",
          "nullable" : "0"
        }, {
          "!" : "Bio::KBase::KIDL::KBT::StructItem",
          "item_type" : {
            "!" : "Bio::KBase::KIDL::KBT::Scalar",
            "annotations" : { },
            "scalar_type" : "string"
          },
          "name" : "alignment_construction_method",
          "nullable" : "0"
        }, {
          "!" : "Bio::KBase::KIDL::KBT::StructItem",
          "item_type" : {
            "!" : "Bio::KBase::KIDL::KBT::Scalar",
            "annotations" : { },
            "scalar_type" : "string"
          },
          "name" : "alignment_construction_parameters",
          "nullable" : "0"
        }, {
          "!" : "Bio::KBase::KIDL::KBT::StructItem",
          "item_type" : {
            "!" : "Bio::KBase::KIDL::KBT::Scalar",
            "annotations" : { },
            "scalar_type" : "string"
          },
          "name" : "alignment_protocol",
          "nullable" : "0"
        }, {
          "!" : "Bio::KBase::KIDL::KBT::StructItem",
          "item_type" : {
            "!" : "Bio::KBase::KIDL::KBT::Scalar",
            "annotations" : { },
            "scalar_type" : "string"
          },
          "name" : "source_db",
          "nullable" : "0"
        }, {
          "!" : "Bio::KBase::KIDL::KBT::StructItem",
          "item_type" : {
            "!" : "Bio::KBase::KIDL::KBT::Scalar",
            "annotations" : { },
            "scalar_type" : "string"
          },
          "name" : "source_id",
          "nullable" : "0"
        } ],
        "module" : "Tree",
        "name" : "alignment_meta_data"
      },
      "annotations" : {
        "metadata" : { },
        "searchable_ws_subset" : { },
        "unknown_annotations" : { }
      },
      "comment" : "Meta data associated with an alignment.\n\n    list<kbase_id> tree_ids - the set of trees that were built from this alignment\n    string status - set to 'active' if this is the latest alignment for a particular set of sequences\n    string sequence_type - indicates what type of sequence is aligned (e.g. protein vs. dna)\n    bool is_concatenation - true if the alignment is based on the concatenation of multiple non-contiguous\n                            sequences, false if each row cooresponds to exactly one sequence (possibly with gaps)\n    timestamp date_created - time at which the alignment was built/loaded in seconds since the epoch\n    int n_rows - number of rows in the alignment\n    int n_cols - number of columns in the alignment\n    string alignment_construction_method - the name of the software tool used to build the alignment\n    string alignment_construction_parameters - set of non-default parameters used to construct the alignment\n    string alignment_protocol - simple free-form text which may provide additional details of how the alignment was built\n    string source_db - the source database where this alignment originated, if one exists\n    string source_id - the id of this alignment in an external database, if one exists",
      "module" : "Tree",
      "name" : "alignment_meta_data"
    }, {
      "!" : "Bio::KBase::KIDL::KBT::Funcdef",
      "annotations" : {
        "unknown_annotations" : { }
      },
      "async" : "0",
      "authentication" : "none",
      "comment" : "Given a tree in newick format, replace the node names indicated as keys in the 'replacements' mapping\nwith new node names indicated as values in the 'replacements' mapping.  Matching is EXACT and will not handle\nregular expression patterns.",
      "name" : "replace_node_names",
      "parameters" : [ {
        "name" : "tree",
        "type" : {
          "!" : "Bio::KBase::KIDL::KBT::Typedef",
          "alias_type" : {
            "!" : "Bio::KBase::KIDL::KBT::Typedef",
            "alias_type" : {
              "!" : "Bio::KBase::KIDL::KBT::Scalar",
              "annotations" : { },
              "scalar_type" : "string"
            },
            "annotations" : {
              "metadata" : { },
              "searchable_ws_subset" : { },
              "unknown_annotations" : { }
            },
            "comment" : "A string representation of a phylogenetic tree.  The format/syntax of the string is\nspecified by using one of the available typedefs declaring a particular format, such as 'newick_tree',\n'phyloXML_tree' or 'json_tree'.  When a format is not explictily specified, it is possible to return\ntrees in different formats depending on addtional parameters. Regardless of format, all leaf nodes\nin trees built from MSAs are indexed to a specific MSA row.  You can use the appropriate functionality\nof the API to replace these IDs with other KBase Ids instead. Internal nodes may or may not be named.\nNodes, depending on the format, may also be annotated with structured data such as bootstrap values and\ndistances.",
            "module" : "Tree",
            "name" : "tree"
          },
          "annotations" : {
            "metadata" : { },
            "searchable_ws_subset" : { },
            "unknown_annotations" : { }
          },
          "comment" : "Trees are represented in KBase by default in newick format (http://en.wikipedia.org/wiki/Newick_format)\nand are returned to you in this format by default.",
          "module" : "Tree",
          "name" : "newick_tree"
        }
      }, {
        "name" : "replacements",
        "type" : {
          "!" : "Bio::KBase::KIDL::KBT::Mapping",
          "annotations" : { },
          "key_type" : {
            "!" : "Bio::KBase::KIDL::KBT::Typedef",
            "alias_type" : {
              "!" : "Bio::KBase::KIDL::KBT::Scalar",
              "annotations" : { },
              "scalar_type" : "string"
            },
            "annotations" : {
              "metadata" : { },
              "searchable_ws_subset" : { },
              "unknown_annotations" : { }
            },
            "comment" : "The string representation of the parsed node name (may be a kbase_id, but does not have to be).  Note that this\nis not the full, raw label in a newick_tree (which may include comments).",
            "module" : "Tree",
            "name" : "node_name"
          },
          "value_type" : {
            "!" : "Bio::KBase::KIDL::KBT::Typedef",
            "alias_type" : {
              "!" : "Bio::KBase::KIDL::KBT::Scalar",
              "annotations" : { },
              "scalar_type" : "string"
            },
            "annotations" : {
              "metadata" : { },
              "searchable_ws_subset" : { },
              "unknown_annotations" : { }
            },
            "comment" : "The string representation of the parsed node name (may be a kbase_id, but does not have to be).  Note that this\nis not the full, raw label in a newick_tree (which may include comments).",
            "module" : "Tree",
            "name" : "node_name"
          }
        }
      } ],
      "return_type" : [ {
        "type" : {
          "!" : "Bio::KBase::KIDL::KBT::Typedef",
          "alias_type" : {
            "!" : "Bio::KBase::KIDL::KBT::Typedef",
            "alias_type" : {
              "!" : "Bio::KBase::KIDL::KBT::Scalar",
              "annotations" : { },
              "scalar_type" : "string"
            },
            "annotations" : {
              "metadata" : { },
              "searchable_ws_subset" : { },
              "unknown_annotations" : { }
            },
            "comment" : "A string representation of a phylogenetic tree.  The format/syntax of the string is\nspecified by using one of the available typedefs declaring a particular format, such as 'newick_tree',\n'phyloXML_tree' or 'json_tree'.  When a format is not explictily specified, it is possible to return\ntrees in different formats depending on addtional parameters. Regardless of format, all leaf nodes\nin trees built from MSAs are indexed to a specific MSA row.  You can use the appropriate functionality\nof the API to replace these IDs with other KBase Ids instead. Internal nodes may or may not be named.\nNodes, depending on the format, may also be annotated with structured data such as bootstrap values and\ndistances.",
            "module" : "Tree",
            "name" : "tree"
          },
          "annotations" : {
            "metadata" : { },
            "searchable_ws_subset" : { },
            "unknown_annotations" : { }
          },
          "comment" : "Trees are represented in KBase by default in newick format (http://en.wikipedia.org/wiki/Newick_format)\nand are returned to you in this format by default.",
          "module" : "Tree",
          "name" : "newick_tree"
        }
      } ]
    }, {
      "!" : "Bio::KBase::KIDL::KBT::Funcdef",
      "annotations" : {
        "unknown_annotations" : { }
      },
      "async" : "0",
      "authentication" : "none",
      "comment" : "Given a tree in newick format, remove the nodes with the given names indicated in the list, and\nsimplify the tree.  Simplifying a tree involves removing unnamed internal nodes that have only one\nchild, and removing unnamed leaf nodes.  During the removal process, edge lengths (if they exist) are\nconserved so that the summed end to end distance between any two nodes left in the tree will remain the same.",
      "name" : "remove_node_names_and_simplify",
      "parameters" : [ {
        "name" : "tree",
        "type" : {
          "!" : "Bio::KBase::KIDL::KBT::Typedef",
          "alias_type" : {
            "!" : "Bio::KBase::KIDL::KBT::Typedef",
            "alias_type" : {
              "!" : "Bio::KBase::KIDL::KBT::Scalar",
              "annotations" : { },
              "scalar_type" : "string"
            },
            "annotations" : {
              "metadata" : { },
              "searchable_ws_subset" : { },
              "unknown_annotations" : { }
            },
            "comment" : "A string representation of a phylogenetic tree.  The format/syntax of the string is\nspecified by using one of the available typedefs declaring a particular format, such as 'newick_tree',\n'phyloXML_tree' or 'json_tree'.  When a format is not explictily specified, it is possible to return\ntrees in different formats depending on addtional parameters. Regardless of format, all leaf nodes\nin trees built from MSAs are indexed to a specific MSA row.  You can use the appropriate functionality\nof the API to replace these IDs with other KBase Ids instead. Internal nodes may or may not be named.\nNodes, depending on the format, may also be annotated with structured data such as bootstrap values and\ndistances.",
            "module" : "Tree",
            "name" : "tree"
          },
          "annotations" : {
            "metadata" : { },
            "searchable_ws_subset" : { },
            "unknown_annotations" : { }
          },
          "comment" : "Trees are represented in KBase by default in newick format (http://en.wikipedia.org/wiki/Newick_format)\nand are returned to you in this format by default.",
          "module" : "Tree",
          "name" : "newick_tree"
        }
      }, {
        "name" : "removal_list",
        "type" : {
          "!" : "Bio::KBase::KIDL::KBT::List",
          "annotations" : { },
          "element_type" : {
            "!" : "Bio::KBase::KIDL::KBT::Typedef",
            "alias_type" : {
              "!" : "Bio::KBase::KIDL::KBT::Scalar",
              "annotations" : { },
              "scalar_type" : "string"
            },
            "annotations" : {
              "metadata" : { },
              "searchable_ws_subset" : { },
              "unknown_annotations" : { }
            },
            "comment" : "The string representation of the parsed node name (may be a kbase_id, but does not have to be).  Note that this\nis not the full, raw label in a newick_tree (which may include comments).",
            "module" : "Tree",
            "name" : "node_name"
          }
        }
      } ],
      "return_type" : [ {
        "type" : {
          "!" : "Bio::KBase::KIDL::KBT::Typedef",
          "alias_type" : {
            "!" : "Bio::KBase::KIDL::KBT::Typedef",
            "alias_type" : {
              "!" : "Bio::KBase::KIDL::KBT::Scalar",
              "annotations" : { },
              "scalar_type" : "string"
            },
            "annotations" : {
              "metadata" : { },
              "searchable_ws_subset" : { },
              "unknown_annotations" : { }
            },
            "comment" : "A string representation of a phylogenetic tree.  The format/syntax of the string is\nspecified by using one of the available typedefs declaring a particular format, such as 'newick_tree',\n'phyloXML_tree' or 'json_tree'.  When a format is not explictily specified, it is possible to return\ntrees in different formats depending on addtional parameters. Regardless of format, all leaf nodes\nin trees built from MSAs are indexed to a specific MSA row.  You can use the appropriate functionality\nof the API to replace these IDs with other KBase Ids instead. Internal nodes may or may not be named.\nNodes, depending on the format, may also be annotated with structured data such as bootstrap values and\ndistances.",
            "module" : "Tree",
            "name" : "tree"
          },
          "annotations" : {
            "metadata" : { },
            "searchable_ws_subset" : { },
            "unknown_annotations" : { }
          },
          "comment" : "Trees are represented in KBase by default in newick format (http://en.wikipedia.org/wiki/Newick_format)\nand are returned to you in this format by default.",
          "module" : "Tree",
          "name" : "newick_tree"
        }
      } ]
    }, {
      "!" : "Bio::KBase::KIDL::KBT::Funcdef",
      "annotations" : {
        "unknown_annotations" : { }
      },
      "async" : "0",
      "authentication" : "none",
      "comment" : "Given a tree in newick format, list the names of the leaf nodes.",
      "name" : "extract_leaf_node_names",
      "parameters" : [ {
        "name" : "tree",
        "type" : {
          "!" : "Bio::KBase::KIDL::KBT::Typedef",
          "alias_type" : {
            "!" : "Bio::KBase::KIDL::KBT::Typedef",
            "alias_type" : {
              "!" : "Bio::KBase::KIDL::KBT::Scalar",
              "annotations" : { },
              "scalar_type" : "string"
            },
            "annotations" : {
              "metadata" : { },
              "searchable_ws_subset" : { },
              "unknown_annotations" : { }
            },
            "comment" : "A string representation of a phylogenetic tree.  The format/syntax of the string is\nspecified by using one of the available typedefs declaring a particular format, such as 'newick_tree',\n'phyloXML_tree' or 'json_tree'.  When a format is not explictily specified, it is possible to return\ntrees in different formats depending on addtional parameters. Regardless of format, all leaf nodes\nin trees built from MSAs are indexed to a specific MSA row.  You can use the appropriate functionality\nof the API to replace these IDs with other KBase Ids instead. Internal nodes may or may not be named.\nNodes, depending on the format, may also be annotated with structured data such as bootstrap values and\ndistances.",
            "module" : "Tree",
            "name" : "tree"
          },
          "annotations" : {
            "metadata" : { },
            "searchable_ws_subset" : { },
            "unknown_annotations" : { }
          },
          "comment" : "Trees are represented in KBase by default in newick format (http://en.wikipedia.org/wiki/Newick_format)\nand are returned to you in this format by default.",
          "module" : "Tree",
          "name" : "newick_tree"
        }
      } ],
      "return_type" : [ {
        "type" : {
          "!" : "Bio::KBase::KIDL::KBT::List",
          "annotations" : { },
          "element_type" : {
            "!" : "Bio::KBase::KIDL::KBT::Typedef",
            "alias_type" : {
              "!" : "Bio::KBase::KIDL::KBT::Scalar",
              "annotations" : { },
              "scalar_type" : "string"
            },
            "annotations" : {
              "metadata" : { },
              "searchable_ws_subset" : { },
              "unknown_annotations" : { }
            },
            "comment" : "The string representation of the parsed node name (may be a kbase_id, but does not have to be).  Note that this\nis not the full, raw label in a newick_tree (which may include comments).",
            "module" : "Tree",
            "name" : "node_name"
          }
        }
      } ]
    }, {
      "!" : "Bio::KBase::KIDL::KBT::Funcdef",
      "annotations" : {
        "unknown_annotations" : { }
      },
      "async" : "0",
      "authentication" : "none",
      "comment" : "Given a tree in newick format, list the names of ALL the nodes.  Note that for some trees, such as\nthose originating from MicrobesOnline, the names of internal nodes may be bootstrap values, but will still\nbe returned by this function.",
      "name" : "extract_node_names",
      "parameters" : [ {
        "name" : "tree",
        "type" : {
          "!" : "Bio::KBase::KIDL::KBT::Typedef",
          "alias_type" : {
            "!" : "Bio::KBase::KIDL::KBT::Typedef",
            "alias_type" : {
              "!" : "Bio::KBase::KIDL::KBT::Scalar",
              "annotations" : { },
              "scalar_type" : "string"
            },
            "annotations" : {
              "metadata" : { },
              "searchable_ws_subset" : { },
              "unknown_annotations" : { }
            },
            "comment" : "A string representation of a phylogenetic tree.  The format/syntax of the string is\nspecified by using one of the available typedefs declaring a particular format, such as 'newick_tree',\n'phyloXML_tree' or 'json_tree'.  When a format is not explictily specified, it is possible to return\ntrees in different formats depending on addtional parameters. Regardless of format, all leaf nodes\nin trees built from MSAs are indexed to a specific MSA row.  You can use the appropriate functionality\nof the API to replace these IDs with other KBase Ids instead. Internal nodes may or may not be named.\nNodes, depending on the format, may also be annotated with structured data such as bootstrap values and\ndistances.",
            "module" : "Tree",
            "name" : "tree"
          },
          "annotations" : {
            "metadata" : { },
            "searchable_ws_subset" : { },
            "unknown_annotations" : { }
          },
          "comment" : "Trees are represented in KBase by default in newick format (http://en.wikipedia.org/wiki/Newick_format)\nand are returned to you in this format by default.",
          "module" : "Tree",
          "name" : "newick_tree"
        }
      } ],
      "return_type" : [ {
        "type" : {
          "!" : "Bio::KBase::KIDL::KBT::List",
          "annotations" : { },
          "element_type" : {
            "!" : "Bio::KBase::KIDL::KBT::Typedef",
            "alias_type" : {
              "!" : "Bio::KBase::KIDL::KBT::Scalar",
              "annotations" : { },
              "scalar_type" : "string"
            },
            "annotations" : {
              "metadata" : { },
              "searchable_ws_subset" : { },
              "unknown_annotations" : { }
            },
            "comment" : "The string representation of the parsed node name (may be a kbase_id, but does not have to be).  Note that this\nis not the full, raw label in a newick_tree (which may include comments).",
            "module" : "Tree",
            "name" : "node_name"
          }
        }
      } ]
    }, {
      "!" : "Bio::KBase::KIDL::KBT::Funcdef",
      "annotations" : {
        "unknown_annotations" : { }
      },
      "async" : "0",
      "authentication" : "none",
      "comment" : "Given a tree, return the total number of nodes, including internal nodes and the root node.",
      "name" : "get_node_count",
      "parameters" : [ {
        "name" : "tree",
        "type" : {
          "!" : "Bio::KBase::KIDL::KBT::Typedef",
          "alias_type" : {
            "!" : "Bio::KBase::KIDL::KBT::Typedef",
            "alias_type" : {
              "!" : "Bio::KBase::KIDL::KBT::Scalar",
              "annotations" : { },
              "scalar_type" : "string"
            },
            "annotations" : {
              "metadata" : { },
              "searchable_ws_subset" : { },
              "unknown_annotations" : { }
            },
            "comment" : "A string representation of a phylogenetic tree.  The format/syntax of the string is\nspecified by using one of the available typedefs declaring a particular format, such as 'newick_tree',\n'phyloXML_tree' or 'json_tree'.  When a format is not explictily specified, it is possible to return\ntrees in different formats depending on addtional parameters. Regardless of format, all leaf nodes\nin trees built from MSAs are indexed to a specific MSA row.  You can use the appropriate functionality\nof the API to replace these IDs with other KBase Ids instead. Internal nodes may or may not be named.\nNodes, depending on the format, may also be annotated with structured data such as bootstrap values and\ndistances.",
            "module" : "Tree",
            "name" : "tree"
          },
          "annotations" : {
            "metadata" : { },
            "searchable_ws_subset" : { },
            "unknown_annotations" : { }
          },
          "comment" : "Trees are represented in KBase by default in newick format (http://en.wikipedia.org/wiki/Newick_format)\nand are returned to you in this format by default.",
          "module" : "Tree",
          "name" : "newick_tree"
        }
      } ],
      "return_type" : [ {
        "type" : {
          "!" : "Bio::KBase::KIDL::KBT::Scalar",
          "annotations" : { },
          "scalar_type" : "int"
        }
      } ]
    }, {
      "!" : "Bio::KBase::KIDL::KBT::Funcdef",
      "annotations" : {
        "unknown_annotations" : { }
      },
      "async" : "0",
      "authentication" : "none",
      "comment" : "Given a tree, return the total number of leaf nodes, (internal and root nodes are ignored).  When the\ntree was based on a multiple sequence alignment, the number of leaves will match the number of sequences\nthat were aligned.",
      "name" : "get_leaf_count",
      "parameters" : [ {
        "name" : "tree",
        "type" : {
          "!" : "Bio::KBase::KIDL::KBT::Typedef",
          "alias_type" : {
            "!" : "Bio::KBase::KIDL::KBT::Typedef",
            "alias_type" : {
              "!" : "Bio::KBase::KIDL::KBT::Scalar",
              "annotations" : { },
              "scalar_type" : "string"
            },
            "annotations" : {
              "metadata" : { },
              "searchable_ws_subset" : { },
              "unknown_annotations" : { }
            },
            "comment" : "A string representation of a phylogenetic tree.  The format/syntax of the string is\nspecified by using one of the available typedefs declaring a particular format, such as 'newick_tree',\n'phyloXML_tree' or 'json_tree'.  When a format is not explictily specified, it is possible to return\ntrees in different formats depending on addtional parameters. Regardless of format, all leaf nodes\nin trees built from MSAs are indexed to a specific MSA row.  You can use the appropriate functionality\nof the API to replace these IDs with other KBase Ids instead. Internal nodes may or may not be named.\nNodes, depending on the format, may also be annotated with structured data such as bootstrap values and\ndistances.",
            "module" : "Tree",
            "name" : "tree"
          },
          "annotations" : {
            "metadata" : { },
            "searchable_ws_subset" : { },
            "unknown_annotations" : { }
          },
          "comment" : "Trees are represented in KBase by default in newick format (http://en.wikipedia.org/wiki/Newick_format)\nand are returned to you in this format by default.",
          "module" : "Tree",
          "name" : "newick_tree"
        }
      } ],
      "return_type" : [ {
        "type" : {
          "!" : "Bio::KBase::KIDL::KBT::Scalar",
          "annotations" : { },
          "scalar_type" : "int"
        }
      } ]
    }, {
      "!" : "Bio::KBase::KIDL::KBT::Funcdef",
      "annotations" : {
        "unknown_annotations" : { }
      },
      "async" : "0",
      "authentication" : "none",
      "comment" : "Returns the specified tree in the specified format, or an empty string if the tree does not exist.\nThe options hash provides a way to return the tree with different labels replaced or with different attached meta\ninformation.  Currently, the available flags and understood options are listed below. \n\n    options = [\n        format => 'newick',\n        newick_label => 'none' || 'raw' || 'feature_id' || 'protein_sequence_id' || 'contig_sequence_id',\n        newick_bootstrap => 'none' || 'internal_node_labels'\n        newick_distance => 'none' || 'raw'\n    ];\n \nThe 'format' key indicates what string format the tree should be returned in.  Currently, there is only\nsupport for 'newick'. The default value if not specified is 'newick'.\n\nThe 'newick_label' key only affects trees returned as newick format, and specifies what should be\nplaced in the label of each leaf.  'none' indicates that no label is added, so you get the structure\nof the tree only.  'raw' indicates that the raw label mapping the leaf to an alignement row is used.\n'feature_id' indicates that the label will have an examplar feature_id in each label (typically the\nfeature that was originally used to define the sequence). Note that exemplar feature_ids are not\ndefined for all trees, so this may result in an empty tree.  'protein_sequence_id' indicates that the\nkbase id of the protein sequence used in the alignment is used.  'contig_sequence_id' indicates that\nthe contig sequence id is added.  Note that trees are typically built with protein sequences OR\ncontig sequences. If you select one type of sequence, but the tree was built with the other type, then\nno labels will be added.  The default value if none is specified is 'raw'.\n\nThe 'newick_bootstrap' key allows control over whether bootstrap values are returned if they exist, and\nhow they are returned.  'none' indicates that no bootstrap values are returned. 'internal_node_labels'\nindicates that bootstrap values are returned as internal node labels.  Default value is 'internal_node_labels';\n\nThe 'newick_distance' key allows control over whether distance labels are generated or not.  If set to\n'none', no distances will be output. Default is 'raw', which outputs the distances exactly as they appeared\nwhen loaded into kbase.",
      "name" : "get_tree",
      "parameters" : [ {
        "name" : "tree_id",
        "type" : {
          "!" : "Bio::KBase::KIDL::KBT::Typedef",
          "alias_type" : {
            "!" : "Bio::KBase::KIDL::KBT::Scalar",
            "annotations" : { },
            "scalar_type" : "string"
          },
          "annotations" : {
            "metadata" : { },
            "searchable_ws_subset" : { },
            "unknown_annotations" : { }
          },
          "comment" : "A KBase ID is a string starting with the characters \"kb|\".  KBase IDs are typed. The types are\ndesignated using a short string. For instance,\" g\" denotes a genome, \"tree\" denotes a Tree, and\n\"aln\" denotes a sequence alignment. KBase IDs may be hierarchical.  For example, if a KBase genome\nidentifier is \"kb|g.1234\", a protein encoding gene within that genome may be represented as\n\"kb|g.1234.peg.771\".",
          "module" : "Tree",
          "name" : "kbase_id"
        }
      }, {
        "name" : "options",
        "type" : {
          "!" : "Bio::KBase::KIDL::KBT::Mapping",
          "annotations" : { },
          "key_type" : {
            "!" : "Bio::KBase::KIDL::KBT::Scalar",
            "annotations" : { },
            "scalar_type" : "string"
          },
          "value_type" : {
            "!" : "Bio::KBase::KIDL::KBT::Scalar",
            "annotations" : { },
            "scalar_type" : "string"
          }
        }
      } ],
      "return_type" : [ {
        "type" : {
          "!" : "Bio::KBase::KIDL::KBT::Typedef",
          "alias_type" : {
            "!" : "Bio::KBase::KIDL::KBT::Scalar",
            "annotations" : { },
            "scalar_type" : "string"
          },
          "annotations" : {
            "metadata" : { },
            "searchable_ws_subset" : { },
            "unknown_annotations" : { }
          },
          "comment" : "A string representation of a phylogenetic tree.  The format/syntax of the string is\nspecified by using one of the available typedefs declaring a particular format, such as 'newick_tree',\n'phyloXML_tree' or 'json_tree'.  When a format is not explictily specified, it is possible to return\ntrees in different formats depending on addtional parameters. Regardless of format, all leaf nodes\nin trees built from MSAs are indexed to a specific MSA row.  You can use the appropriate functionality\nof the API to replace these IDs with other KBase Ids instead. Internal nodes may or may not be named.\nNodes, depending on the format, may also be annotated with structured data such as bootstrap values and\ndistances.",
          "module" : "Tree",
          "name" : "tree"
        }
      } ]
    }, {
      "!" : "Bio::KBase::KIDL::KBT::Funcdef",
      "annotations" : {
        "unknown_annotations" : { }
      },
      "async" : "0",
      "authentication" : "none",
      "comment" : "Returns the specified alignment in the specified format, or an empty string if the alignment does not exist.\nThe options hash provides a way to return the alignment with different labels replaced or with different attached meta\ninformation.  Currently, the available flags and understood options are listed below. \n\n    options = [\n        format => 'fasta',\n        sequence_label => 'none' || 'raw' || 'feature_id' || 'protein_sequence_id' || 'contig_sequence_id',\n    ];\n \nThe 'format' key indicates what string format the alignment should be returned in.  Currently, there is only\nsupport for 'fasta'. The default value if not specified is 'fasta'.\n\nThe 'sequence_label' specifies what should be placed in the label of each sequence.  'none' indicates that\nno label is added, so you get the sequence only.  'raw' indicates that the raw label of the alignement row\nis used. 'feature_id' indicates that the label will have an examplar feature_id in each label (typically the\nfeature that was originally used to define the sequence). Note that exemplar feature_ids are not\ndefined for all alignments, so this may result in an unlabeled alignment.  'protein_sequence_id' indicates\nthat the kbase id of the protein sequence used in the alignment is used.  'contig_sequence_id' indicates that\nthe contig sequence id is used.  Note that trees are typically built with protein sequences OR\ncontig sequences. If you select one type of sequence, but the alignment was built with the other type, then\nno labels will be added.  The default value if none is specified is 'raw'.",
      "name" : "get_alignment",
      "parameters" : [ {
        "name" : "alignment_id",
        "type" : {
          "!" : "Bio::KBase::KIDL::KBT::Typedef",
          "alias_type" : {
            "!" : "Bio::KBase::KIDL::KBT::Scalar",
            "annotations" : { },
            "scalar_type" : "string"
          },
          "annotations" : {
            "metadata" : { },
            "searchable_ws_subset" : { },
            "unknown_annotations" : { }
          },
          "comment" : "A KBase ID is a string starting with the characters \"kb|\".  KBase IDs are typed. The types are\ndesignated using a short string. For instance,\" g\" denotes a genome, \"tree\" denotes a Tree, and\n\"aln\" denotes a sequence alignment. KBase IDs may be hierarchical.  For example, if a KBase genome\nidentifier is \"kb|g.1234\", a protein encoding gene within that genome may be represented as\n\"kb|g.1234.peg.771\".",
          "module" : "Tree",
          "name" : "kbase_id"
        }
      }, {
        "name" : "options",
        "type" : {
          "!" : "Bio::KBase::KIDL::KBT::Mapping",
          "annotations" : { },
          "key_type" : {
            "!" : "Bio::KBase::KIDL::KBT::Scalar",
            "annotations" : { },
            "scalar_type" : "string"
          },
          "value_type" : {
            "!" : "Bio::KBase::KIDL::KBT::Scalar",
            "annotations" : { },
            "scalar_type" : "string"
          }
        }
      } ],
      "return_type" : [ {
        "type" : {
          "!" : "Bio::KBase::KIDL::KBT::Typedef",
          "alias_type" : {
            "!" : "Bio::KBase::KIDL::KBT::Scalar",
            "annotations" : { },
            "scalar_type" : "string"
          },
          "annotations" : {
            "metadata" : { },
            "searchable_ws_subset" : { },
            "unknown_annotations" : { }
          },
          "comment" : "String representation of a sequence alignment, the format of which may be different depending on\ninput options for retrieving the alignment.",
          "module" : "Tree",
          "name" : "alignment"
        }
      } ]
    }, {
      "!" : "Bio::KBase::KIDL::KBT::Funcdef",
      "annotations" : {
        "unknown_annotations" : { }
      },
      "async" : "0",
      "authentication" : "none",
      "comment" : "Get meta data associated with each of the trees indicated in the list by tree id.  Note that some meta\ndata may not be available for trees which are not built from alignments.  Also note that this method\ncomputes the number of nodes and leaves for each tree, so may be slow for very large trees or very long\nlists.  If you do not need this full meta information structure, it may be faster to directly query the\nCDS for just the field you need using the CDMI.",
      "name" : "get_tree_data",
      "parameters" : [ {
        "name" : "tree_ids",
        "type" : {
          "!" : "Bio::KBase::KIDL::KBT::List",
          "annotations" : { },
          "element_type" : {
            "!" : "Bio::KBase::KIDL::KBT::Typedef",
            "alias_type" : {
              "!" : "Bio::KBase::KIDL::KBT::Scalar",
              "annotations" : { },
              "scalar_type" : "string"
            },
            "annotations" : {
              "metadata" : { },
              "searchable_ws_subset" : { },
              "unknown_annotations" : { }
            },
            "comment" : "A KBase ID is a string starting with the characters \"kb|\".  KBase IDs are typed. The types are\ndesignated using a short string. For instance,\" g\" denotes a genome, \"tree\" denotes a Tree, and\n\"aln\" denotes a sequence alignment. KBase IDs may be hierarchical.  For example, if a KBase genome\nidentifier is \"kb|g.1234\", a protein encoding gene within that genome may be represented as\n\"kb|g.1234.peg.771\".",
            "module" : "Tree",
            "name" : "kbase_id"
          }
        }
      } ],
      "return_type" : [ {
        "type" : {
          "!" : "Bio::KBase::KIDL::KBT::Mapping",
          "annotations" : { },
          "key_type" : {
            "!" : "Bio::KBase::KIDL::KBT::Typedef",
            "alias_type" : {
              "!" : "Bio::KBase::KIDL::KBT::Scalar",
              "annotations" : { },
              "scalar_type" : "string"
            },
            "annotations" : {
              "metadata" : { },
              "searchable_ws_subset" : { },
              "unknown_annotations" : { }
            },
            "comment" : "A KBase ID is a string starting with the characters \"kb|\".  KBase IDs are typed. The types are\ndesignated using a short string. For instance,\" g\" denotes a genome, \"tree\" denotes a Tree, and\n\"aln\" denotes a sequence alignment. KBase IDs may be hierarchical.  For example, if a KBase genome\nidentifier is \"kb|g.1234\", a protein encoding gene within that genome may be represented as\n\"kb|g.1234.peg.771\".",
            "module" : "Tree",
            "name" : "kbase_id"
          },
          "value_type" : {
            "!" : "Bio::KBase::KIDL::KBT::Typedef",
            "alias_type" : {
              "!" : "Bio::KBase::KIDL::KBT::Struct",
              "annotations" : {
                "metadata" : { },
                "searchable_ws_subset" : { }
              },
              "comment" : "Meta data associated with a tree.\n\n    kbase_id alignment_id - if this tree was built from an alignment, this provides that alignment id\n    string type - the type of tree; possible values currently are \"sequence_alignment\" and \"genome\" for trees\n                  either built from a sequence alignment, or imported directly indexed to genomes.\n    string status - set to 'active' if this is the latest built tree for a particular gene family\n    timestamp date_created - time at which the tree was built/loaded in seconds since the epoch\n    string tree_contruction_method - the name of the software used to construct the tree\n    string tree_construction_parameters - any non-default parameters of the tree construction method\n    string tree_protocol - simple free-form text which may provide additional details of how the tree was built\n    int node_count - total number of nodes in the tree\n    int leaf_count - total number of leaf nodes in the tree (generally this cooresponds to the number of sequences)\n    string source_db - the source database where this tree originated, if one exists\n    string source_id - the id of this tree in an external database, if one exists",
              "items" : [ {
                "!" : "Bio::KBase::KIDL::KBT::StructItem",
                "item_type" : {
                  "!" : "Bio::KBase::KIDL::KBT::Typedef",
                  "alias_type" : {
                    "!" : "Bio::KBase::KIDL::KBT::Scalar",
                    "annotations" : { },
                    "scalar_type" : "string"
                  },
                  "annotations" : {
                    "metadata" : { },
                    "searchable_ws_subset" : { },
                    "unknown_annotations" : { }
                  },
                  "comment" : "A KBase ID is a string starting with the characters \"kb|\".  KBase IDs are typed. The types are\ndesignated using a short string. For instance,\" g\" denotes a genome, \"tree\" denotes a Tree, and\n\"aln\" denotes a sequence alignment. KBase IDs may be hierarchical.  For example, if a KBase genome\nidentifier is \"kb|g.1234\", a protein encoding gene within that genome may be represented as\n\"kb|g.1234.peg.771\".",
                  "module" : "Tree",
                  "name" : "kbase_id"
                },
                "name" : "alignment_id",
                "nullable" : "0"
              }, {
                "!" : "Bio::KBase::KIDL::KBT::StructItem",
                "item_type" : {
                  "!" : "Bio::KBase::KIDL::KBT::Scalar",
                  "annotations" : { },
                  "scalar_type" : "string"
                },
                "name" : "type",
                "nullable" : "0"
              }, {
                "!" : "Bio::KBase::KIDL::KBT::StructItem",
                "item_type" : {
                  "!" : "Bio::KBase::KIDL::KBT::Scalar",
                  "annotations" : { },
                  "scalar_type" : "string"
                },
                "name" : "status",
                "nullable" : "0"
              }, {
                "!" : "Bio::KBase::KIDL::KBT::StructItem",
                "item_type" : {
                  "!" : "Bio::KBase::KIDL::KBT::Typedef",
                  "alias_type" : {
                    "!" : "Bio::KBase::KIDL::KBT::Scalar",
                    "annotations" : { },
                    "scalar_type" : "string"
                  },
                  "annotations" : {
                    "metadata" : { },
                    "searchable_ws_subset" : { },
                    "unknown_annotations" : { }
                  },
                  "comment" : "time in units of number of seconds since the epoch",
                  "module" : "Tree",
                  "name" : "timestamp"
                },
                "name" : "date_created",
                "nullable" : "0"
              }, {
                "!" : "Bio::KBase::KIDL::KBT::StructItem",
                "item_type" : {
                  "!" : "Bio::KBase::KIDL::KBT::Scalar",
                  "annotations" : { },
                  "scalar_type" : "string"
                },
                "name" : "tree_contruction_method",
                "nullable" : "0"
              }, {
                "!" : "Bio::KBase::KIDL::KBT::StructItem",
                "item_type" : {
                  "!" : "Bio::KBase::KIDL::KBT::Scalar",
                  "annotations" : { },
                  "scalar_type" : "string"
                },
                "name" : "tree_construction_parameters",
                "nullable" : "0"
              }, {
                "!" : "Bio::KBase::KIDL::KBT::StructItem",
                "item_type" : {
                  "!" : "Bio::KBase::KIDL::KBT::Scalar",
                  "annotations" : { },
                  "scalar_type" : "string"
                },
                "name" : "tree_protocol",
                "nullable" : "0"
              }, {
                "!" : "Bio::KBase::KIDL::KBT::StructItem",
                "item_type" : {
                  "!" : "Bio::KBase::KIDL::KBT::Scalar",
                  "annotations" : { },
                  "scalar_type" : "int"
                },
                "name" : "node_count",
                "nullable" : "0"
              }, {
                "!" : "Bio::KBase::KIDL::KBT::StructItem",
                "item_type" : {
                  "!" : "Bio::KBase::KIDL::KBT::Scalar",
                  "annotations" : { },
                  "scalar_type" : "int"
                },
                "name" : "leaf_count",
                "nullable" : "0"
              }, {
                "!" : "Bio::KBase::KIDL::KBT::StructItem",
                "item_type" : {
                  "!" : "Bio::KBase::KIDL::KBT::Scalar",
                  "annotations" : { },
                  "scalar_type" : "string"
                },
                "name" : "source_db",
                "nullable" : "0"
              }, {
                "!" : "Bio::KBase::KIDL::KBT::StructItem",
                "item_type" : {
                  "!" : "Bio::KBase::KIDL::KBT::Scalar",
                  "annotations" : { },
                  "scalar_type" : "string"
                },
                "name" : "source_id",
                "nullable" : "0"
              } ],
              "module" : "Tree",
              "name" : "tree_meta_data"
            },
            "annotations" : {
              "metadata" : { },
              "searchable_ws_subset" : { },
              "unknown_annotations" : { }
            },
            "comment" : "Meta data associated with a tree.\n\n    kbase_id alignment_id - if this tree was built from an alignment, this provides that alignment id\n    string type - the type of tree; possible values currently are \"sequence_alignment\" and \"genome\" for trees\n                  either built from a sequence alignment, or imported directly indexed to genomes.\n    string status - set to 'active' if this is the latest built tree for a particular gene family\n    timestamp date_created - time at which the tree was built/loaded in seconds since the epoch\n    string tree_contruction_method - the name of the software used to construct the tree\n    string tree_construction_parameters - any non-default parameters of the tree construction method\n    string tree_protocol - simple free-form text which may provide additional details of how the tree was built\n    int node_count - total number of nodes in the tree\n    int leaf_count - total number of leaf nodes in the tree (generally this cooresponds to the number of sequences)\n    string source_db - the source database where this tree originated, if one exists\n    string source_id - the id of this tree in an external database, if one exists",
            "module" : "Tree",
            "name" : "tree_meta_data"
          }
        }
      } ]
    }, {
      "!" : "Bio::KBase::KIDL::KBT::Funcdef",
      "annotations" : {
        "unknown_annotations" : { }
      },
      "async" : "0",
      "authentication" : "none",
      "comment" : "Get meta data associated with each of the trees indicated in the list by tree id.  Note that some meta\ndata may not be available for trees which are not built from alignments.  Also note that this method\ncomputes the number of nodes and leaves for each tree, so may be slow for very large trees or very long\nlists.  If you do not need this full meta information structure, it may be faster to directly query the\nCDS for just the field you need using the CDMI.",
      "name" : "get_alignment_data",
      "parameters" : [ {
        "name" : "alignment_ids",
        "type" : {
          "!" : "Bio::KBase::KIDL::KBT::List",
          "annotations" : { },
          "element_type" : {
            "!" : "Bio::KBase::KIDL::KBT::Typedef",
            "alias_type" : {
              "!" : "Bio::KBase::KIDL::KBT::Scalar",
              "annotations" : { },
              "scalar_type" : "string"
            },
            "annotations" : {
              "metadata" : { },
              "searchable_ws_subset" : { },
              "unknown_annotations" : { }
            },
            "comment" : "A KBase ID is a string starting with the characters \"kb|\".  KBase IDs are typed. The types are\ndesignated using a short string. For instance,\" g\" denotes a genome, \"tree\" denotes a Tree, and\n\"aln\" denotes a sequence alignment. KBase IDs may be hierarchical.  For example, if a KBase genome\nidentifier is \"kb|g.1234\", a protein encoding gene within that genome may be represented as\n\"kb|g.1234.peg.771\".",
            "module" : "Tree",
            "name" : "kbase_id"
          }
        }
      } ],
      "return_type" : [ {
        "type" : {
          "!" : "Bio::KBase::KIDL::KBT::Mapping",
          "annotations" : { },
          "key_type" : {
            "!" : "Bio::KBase::KIDL::KBT::Typedef",
            "alias_type" : {
              "!" : "Bio::KBase::KIDL::KBT::Scalar",
              "annotations" : { },
              "scalar_type" : "string"
            },
            "annotations" : {
              "metadata" : { },
              "searchable_ws_subset" : { },
              "unknown_annotations" : { }
            },
            "comment" : "A KBase ID is a string starting with the characters \"kb|\".  KBase IDs are typed. The types are\ndesignated using a short string. For instance,\" g\" denotes a genome, \"tree\" denotes a Tree, and\n\"aln\" denotes a sequence alignment. KBase IDs may be hierarchical.  For example, if a KBase genome\nidentifier is \"kb|g.1234\", a protein encoding gene within that genome may be represented as\n\"kb|g.1234.peg.771\".",
            "module" : "Tree",
            "name" : "kbase_id"
          },
          "value_type" : {
            "!" : "Bio::KBase::KIDL::KBT::Typedef",
            "alias_type" : {
              "!" : "Bio::KBase::KIDL::KBT::Struct",
              "annotations" : {
                "metadata" : { },
                "searchable_ws_subset" : { }
              },
              "comment" : "Meta data associated with an alignment.\n\n    list<kbase_id> tree_ids - the set of trees that were built from this alignment\n    string status - set to 'active' if this is the latest alignment for a particular set of sequences\n    string sequence_type - indicates what type of sequence is aligned (e.g. protein vs. dna)\n    bool is_concatenation - true if the alignment is based on the concatenation of multiple non-contiguous\n                            sequences, false if each row cooresponds to exactly one sequence (possibly with gaps)\n    timestamp date_created - time at which the alignment was built/loaded in seconds since the epoch\n    int n_rows - number of rows in the alignment\n    int n_cols - number of columns in the alignment\n    string alignment_construction_method - the name of the software tool used to build the alignment\n    string alignment_construction_parameters - set of non-default parameters used to construct the alignment\n    string alignment_protocol - simple free-form text which may provide additional details of how the alignment was built\n    string source_db - the source database where this alignment originated, if one exists\n    string source_id - the id of this alignment in an external database, if one exists",
              "items" : [ {
                "!" : "Bio::KBase::KIDL::KBT::StructItem",
                "item_type" : {
                  "!" : "Bio::KBase::KIDL::KBT::List",
                  "annotations" : { },
                  "element_type" : {
                    "!" : "Bio::KBase::KIDL::KBT::Typedef",
                    "alias_type" : {
                      "!" : "Bio::KBase::KIDL::KBT::Scalar",
                      "annotations" : { },
                      "scalar_type" : "string"
                    },
                    "annotations" : {
                      "metadata" : { },
                      "searchable_ws_subset" : { },
                      "unknown_annotations" : { }
                    },
                    "comment" : "A KBase ID is a string starting with the characters \"kb|\".  KBase IDs are typed. The types are\ndesignated using a short string. For instance,\" g\" denotes a genome, \"tree\" denotes a Tree, and\n\"aln\" denotes a sequence alignment. KBase IDs may be hierarchical.  For example, if a KBase genome\nidentifier is \"kb|g.1234\", a protein encoding gene within that genome may be represented as\n\"kb|g.1234.peg.771\".",
                    "module" : "Tree",
                    "name" : "kbase_id"
                  }
                },
                "name" : "tree_ids",
                "nullable" : "0"
              }, {
                "!" : "Bio::KBase::KIDL::KBT::StructItem",
                "item_type" : {
                  "!" : "Bio::KBase::KIDL::KBT::Scalar",
                  "annotations" : { },
                  "scalar_type" : "string"
                },
                "name" : "status",
                "nullable" : "0"
              }, {
                "!" : "Bio::KBase::KIDL::KBT::StructItem",
                "item_type" : {
                  "!" : "Bio::KBase::KIDL::KBT::Scalar",
                  "annotations" : { },
                  "scalar_type" : "string"
                },
                "name" : "sequence_type",
                "nullable" : "0"
              }, {
                "!" : "Bio::KBase::KIDL::KBT::StructItem",
                "item_type" : {
                  "!" : "Bio::KBase::KIDL::KBT::Scalar",
                  "annotations" : { },
                  "scalar_type" : "string"
                },
                "name" : "is_concatenation",
                "nullable" : "0"
              }, {
                "!" : "Bio::KBase::KIDL::KBT::StructItem",
                "item_type" : {
                  "!" : "Bio::KBase::KIDL::KBT::Typedef",
                  "alias_type" : {
                    "!" : "Bio::KBase::KIDL::KBT::Scalar",
                    "annotations" : { },
                    "scalar_type" : "string"
                  },
                  "annotations" : {
                    "metadata" : { },
                    "searchable_ws_subset" : { },
                    "unknown_annotations" : { }
                  },
                  "comment" : "time in units of number of seconds since the epoch",
                  "module" : "Tree",
                  "name" : "timestamp"
                },
                "name" : "date_created",
                "nullable" : "0"
              }, {
                "!" : "Bio::KBase::KIDL::KBT::StructItem",
                "item_type" : {
                  "!" : "Bio::KBase::KIDL::KBT::Scalar",
                  "annotations" : { },
                  "scalar_type" : "int"
                },
                "name" : "n_rows",
                "nullable" : "0"
              }, {
                "!" : "Bio::KBase::KIDL::KBT::StructItem",
                "item_type" : {
                  "!" : "Bio::KBase::KIDL::KBT::Scalar",
                  "annotations" : { },
                  "scalar_type" : "int"
                },
                "name" : "n_cols",
                "nullable" : "0"
              }, {
                "!" : "Bio::KBase::KIDL::KBT::StructItem",
                "item_type" : {
                  "!" : "Bio::KBase::KIDL::KBT::Scalar",
                  "annotations" : { },
                  "scalar_type" : "string"
                },
                "name" : "alignment_construction_method",
                "nullable" : "0"
              }, {
                "!" : "Bio::KBase::KIDL::KBT::StructItem",
                "item_type" : {
                  "!" : "Bio::KBase::KIDL::KBT::Scalar",
                  "annotations" : { },
                  "scalar_type" : "string"
                },
                "name" : "alignment_construction_parameters",
                "nullable" : "0"
              }, {
                "!" : "Bio::KBase::KIDL::KBT::StructItem",
                "item_type" : {
                  "!" : "Bio::KBase::KIDL::KBT::Scalar",
                  "annotations" : { },
                  "scalar_type" : "string"
                },
                "name" : "alignment_protocol",
                "nullable" : "0"
              }, {
                "!" : "Bio::KBase::KIDL::KBT::StructItem",
                "item_type" : {
                  "!" : "Bio::KBase::KIDL::KBT::Scalar",
                  "annotations" : { },
                  "scalar_type" : "string"
                },
                "name" : "source_db",
                "nullable" : "0"
              }, {
                "!" : "Bio::KBase::KIDL::KBT::StructItem",
                "item_type" : {
                  "!" : "Bio::KBase::KIDL::KBT::Scalar",
                  "annotations" : { },
                  "scalar_type" : "string"
                },
                "name" : "source_id",
                "nullable" : "0"
              } ],
              "module" : "Tree",
              "name" : "alignment_meta_data"
            },
            "annotations" : {
              "metadata" : { },
              "searchable_ws_subset" : { },
              "unknown_annotations" : { }
            },
            "comment" : "Meta data associated with an alignment.\n\n    list<kbase_id> tree_ids - the set of trees that were built from this alignment\n    string status - set to 'active' if this is the latest alignment for a particular set of sequences\n    string sequence_type - indicates what type of sequence is aligned (e.g. protein vs. dna)\n    bool is_concatenation - true if the alignment is based on the concatenation of multiple non-contiguous\n                            sequences, false if each row cooresponds to exactly one sequence (possibly with gaps)\n    timestamp date_created - time at which the alignment was built/loaded in seconds since the epoch\n    int n_rows - number of rows in the alignment\n    int n_cols - number of columns in the alignment\n    string alignment_construction_method - the name of the software tool used to build the alignment\n    string alignment_construction_parameters - set of non-default parameters used to construct the alignment\n    string alignment_protocol - simple free-form text which may provide additional details of how the alignment was built\n    string source_db - the source database where this alignment originated, if one exists\n    string source_id - the id of this alignment in an external database, if one exists",
            "module" : "Tree",
            "name" : "alignment_meta_data"
          }
        }
      } ]
    }, {
      "!" : "Bio::KBase::KIDL::KBT::Funcdef",
      "annotations" : {
        "unknown_annotations" : { }
      },
      "async" : "0",
      "authentication" : "none",
      "comment" : "Given a list of feature ids in kbase, the protein sequence of each feature (if the sequence exists)\nis identified and used to retrieve all trees by ID that were built using the given protein sequence.",
      "name" : "get_tree_ids_by_feature",
      "parameters" : [ {
        "name" : "feature_ids",
        "type" : {
          "!" : "Bio::KBase::KIDL::KBT::List",
          "annotations" : { },
          "element_type" : {
            "!" : "Bio::KBase::KIDL::KBT::Typedef",
            "alias_type" : {
              "!" : "Bio::KBase::KIDL::KBT::Scalar",
              "annotations" : { },
              "scalar_type" : "string"
            },
            "annotations" : {
              "metadata" : { },
              "searchable_ws_subset" : { },
              "unknown_annotations" : { }
            },
            "comment" : "A KBase ID is a string starting with the characters \"kb|\".  KBase IDs are typed. The types are\ndesignated using a short string. For instance,\" g\" denotes a genome, \"tree\" denotes a Tree, and\n\"aln\" denotes a sequence alignment. KBase IDs may be hierarchical.  For example, if a KBase genome\nidentifier is \"kb|g.1234\", a protein encoding gene within that genome may be represented as\n\"kb|g.1234.peg.771\".",
            "module" : "Tree",
            "name" : "kbase_id"
          }
        }
      } ],
      "return_type" : [ {
        "type" : {
          "!" : "Bio::KBase::KIDL::KBT::List",
          "annotations" : { },
          "element_type" : {
            "!" : "Bio::KBase::KIDL::KBT::Typedef",
            "alias_type" : {
              "!" : "Bio::KBase::KIDL::KBT::Scalar",
              "annotations" : { },
              "scalar_type" : "string"
            },
            "annotations" : {
              "metadata" : { },
              "searchable_ws_subset" : { },
              "unknown_annotations" : { }
            },
            "comment" : "A KBase ID is a string starting with the characters \"kb|\".  KBase IDs are typed. The types are\ndesignated using a short string. For instance,\" g\" denotes a genome, \"tree\" denotes a Tree, and\n\"aln\" denotes a sequence alignment. KBase IDs may be hierarchical.  For example, if a KBase genome\nidentifier is \"kb|g.1234\", a protein encoding gene within that genome may be represented as\n\"kb|g.1234.peg.771\".",
            "module" : "Tree",
            "name" : "kbase_id"
          }
        }
      } ]
    }, {
      "!" : "Bio::KBase::KIDL::KBT::Funcdef",
      "annotations" : {
        "unknown_annotations" : { }
      },
      "async" : "0",
      "authentication" : "none",
      "comment" : "Given a list of kbase ids of a protein sequences (their MD5s), retrieve the tree ids of trees that\nwere built based on these sequences.",
      "name" : "get_tree_ids_by_protein_sequence",
      "parameters" : [ {
        "name" : "protein_sequence_ids",
        "type" : {
          "!" : "Bio::KBase::KIDL::KBT::List",
          "annotations" : { },
          "element_type" : {
            "!" : "Bio::KBase::KIDL::KBT::Typedef",
            "alias_type" : {
              "!" : "Bio::KBase::KIDL::KBT::Scalar",
              "annotations" : { },
              "scalar_type" : "string"
            },
            "annotations" : {
              "metadata" : { },
              "searchable_ws_subset" : { },
              "unknown_annotations" : { }
            },
            "comment" : "A KBase ID is a string starting with the characters \"kb|\".  KBase IDs are typed. The types are\ndesignated using a short string. For instance,\" g\" denotes a genome, \"tree\" denotes a Tree, and\n\"aln\" denotes a sequence alignment. KBase IDs may be hierarchical.  For example, if a KBase genome\nidentifier is \"kb|g.1234\", a protein encoding gene within that genome may be represented as\n\"kb|g.1234.peg.771\".",
            "module" : "Tree",
            "name" : "kbase_id"
          }
        }
      } ],
      "return_type" : [ {
        "type" : {
          "!" : "Bio::KBase::KIDL::KBT::List",
          "annotations" : { },
          "element_type" : {
            "!" : "Bio::KBase::KIDL::KBT::Typedef",
            "alias_type" : {
              "!" : "Bio::KBase::KIDL::KBT::Scalar",
              "annotations" : { },
              "scalar_type" : "string"
            },
            "annotations" : {
              "metadata" : { },
              "searchable_ws_subset" : { },
              "unknown_annotations" : { }
            },
            "comment" : "A KBase ID is a string starting with the characters \"kb|\".  KBase IDs are typed. The types are\ndesignated using a short string. For instance,\" g\" denotes a genome, \"tree\" denotes a Tree, and\n\"aln\" denotes a sequence alignment. KBase IDs may be hierarchical.  For example, if a KBase genome\nidentifier is \"kb|g.1234\", a protein encoding gene within that genome may be represented as\n\"kb|g.1234.peg.771\".",
            "module" : "Tree",
            "name" : "kbase_id"
          }
        }
      } ]
    }, {
      "!" : "Bio::KBase::KIDL::KBT::Funcdef",
      "annotations" : {
        "unknown_annotations" : { }
      },
      "async" : "0",
      "authentication" : "none",
      "comment" : "Given a list of feature ids in kbase, the protein sequence of each feature (if the sequence exists)\nis identified and used to retrieve all alignments by ID that were built using the given protein sequence.",
      "name" : "get_alignment_ids_by_feature",
      "parameters" : [ {
        "name" : "feature_ids",
        "type" : {
          "!" : "Bio::KBase::KIDL::KBT::List",
          "annotations" : { },
          "element_type" : {
            "!" : "Bio::KBase::KIDL::KBT::Typedef",
            "alias_type" : {
              "!" : "Bio::KBase::KIDL::KBT::Scalar",
              "annotations" : { },
              "scalar_type" : "string"
            },
            "annotations" : {
              "metadata" : { },
              "searchable_ws_subset" : { },
              "unknown_annotations" : { }
            },
            "comment" : "A KBase ID is a string starting with the characters \"kb|\".  KBase IDs are typed. The types are\ndesignated using a short string. For instance,\" g\" denotes a genome, \"tree\" denotes a Tree, and\n\"aln\" denotes a sequence alignment. KBase IDs may be hierarchical.  For example, if a KBase genome\nidentifier is \"kb|g.1234\", a protein encoding gene within that genome may be represented as\n\"kb|g.1234.peg.771\".",
            "module" : "Tree",
            "name" : "kbase_id"
          }
        }
      } ],
      "return_type" : [ {
        "type" : {
          "!" : "Bio::KBase::KIDL::KBT::List",
          "annotations" : { },
          "element_type" : {
            "!" : "Bio::KBase::KIDL::KBT::Typedef",
            "alias_type" : {
              "!" : "Bio::KBase::KIDL::KBT::Scalar",
              "annotations" : { },
              "scalar_type" : "string"
            },
            "annotations" : {
              "metadata" : { },
              "searchable_ws_subset" : { },
              "unknown_annotations" : { }
            },
            "comment" : "A KBase ID is a string starting with the characters \"kb|\".  KBase IDs are typed. The types are\ndesignated using a short string. For instance,\" g\" denotes a genome, \"tree\" denotes a Tree, and\n\"aln\" denotes a sequence alignment. KBase IDs may be hierarchical.  For example, if a KBase genome\nidentifier is \"kb|g.1234\", a protein encoding gene within that genome may be represented as\n\"kb|g.1234.peg.771\".",
            "module" : "Tree",
            "name" : "kbase_id"
          }
        }
      } ]
    }, {
      "!" : "Bio::KBase::KIDL::KBT::Funcdef",
      "annotations" : {
        "unknown_annotations" : { }
      },
      "async" : "0",
      "authentication" : "none",
      "comment" : "Given a list of kbase ids of a protein sequences (their MD5s), retrieve the alignment ids of trees that\nwere built based on these sequences.",
      "name" : "get_alignment_ids_by_protein_sequence",
      "parameters" : [ {
        "name" : "protein_sequence_ids",
        "type" : {
          "!" : "Bio::KBase::KIDL::KBT::List",
          "annotations" : { },
          "element_type" : {
            "!" : "Bio::KBase::KIDL::KBT::Typedef",
            "alias_type" : {
              "!" : "Bio::KBase::KIDL::KBT::Scalar",
              "annotations" : { },
              "scalar_type" : "string"
            },
            "annotations" : {
              "metadata" : { },
              "searchable_ws_subset" : { },
              "unknown_annotations" : { }
            },
            "comment" : "A KBase ID is a string starting with the characters \"kb|\".  KBase IDs are typed. The types are\ndesignated using a short string. For instance,\" g\" denotes a genome, \"tree\" denotes a Tree, and\n\"aln\" denotes a sequence alignment. KBase IDs may be hierarchical.  For example, if a KBase genome\nidentifier is \"kb|g.1234\", a protein encoding gene within that genome may be represented as\n\"kb|g.1234.peg.771\".",
            "module" : "Tree",
            "name" : "kbase_id"
          }
        }
      } ],
      "return_type" : [ {
        "type" : {
          "!" : "Bio::KBase::KIDL::KBT::List",
          "annotations" : { },
          "element_type" : {
            "!" : "Bio::KBase::KIDL::KBT::Typedef",
            "alias_type" : {
              "!" : "Bio::KBase::KIDL::KBT::Scalar",
              "annotations" : { },
              "scalar_type" : "string"
            },
            "annotations" : {
              "metadata" : { },
              "searchable_ws_subset" : { },
              "unknown_annotations" : { }
            },
            "comment" : "A KBase ID is a string starting with the characters \"kb|\".  KBase IDs are typed. The types are\ndesignated using a short string. For instance,\" g\" denotes a genome, \"tree\" denotes a Tree, and\n\"aln\" denotes a sequence alignment. KBase IDs may be hierarchical.  For example, if a KBase genome\nidentifier is \"kb|g.1234\", a protein encoding gene within that genome may be represented as\n\"kb|g.1234.peg.771\".",
            "module" : "Tree",
            "name" : "kbase_id"
          }
        }
      } ]
    }, {
      "!" : "Bio::KBase::KIDL::KBT::Funcdef",
      "annotations" : {
        "unknown_annotations" : { }
      },
      "async" : "0",
      "authentication" : "none",
      "comment" : "This method searches for a tree having a source ID that matches the input pattern.  This method accepts\none argument, which is the pattern.  The pattern is very simple and includes only two special characters,\nwildcard character, '*', and a match-once character, '.'  The wildcard character matches any number (including\n0) of any character, the '.' matches exactly one of any character.  These special characters can be escaped\nwith a backslash.  To match a blackslash literally, you must also escape it.  Note that source IDs are\ngenerally defined by the gene family model which was used to identifiy the sequences to be included in\nthe tree.  Therefore, matching a source ID is a convenient way to find trees for a specific set of gene\nfamilies.",
      "name" : "get_tree_ids_by_source_id_pattern",
      "parameters" : [ {
        "name" : "pattern",
        "type" : {
          "!" : "Bio::KBase::KIDL::KBT::Scalar",
          "annotations" : { },
          "scalar_type" : "string"
        }
      } ],
      "return_type" : [ {
        "type" : {
          "!" : "Bio::KBase::KIDL::KBT::List",
          "annotations" : { },
          "element_type" : {
            "!" : "Bio::KBase::KIDL::KBT::List",
            "annotations" : { },
            "element_type" : {
              "!" : "Bio::KBase::KIDL::KBT::Typedef",
              "alias_type" : {
                "!" : "Bio::KBase::KIDL::KBT::Scalar",
                "annotations" : { },
                "scalar_type" : "string"
              },
              "annotations" : {
                "metadata" : { },
                "searchable_ws_subset" : { },
                "unknown_annotations" : { }
              },
              "comment" : "A KBase ID is a string starting with the characters \"kb|\".  KBase IDs are typed. The types are\ndesignated using a short string. For instance,\" g\" denotes a genome, \"tree\" denotes a Tree, and\n\"aln\" denotes a sequence alignment. KBase IDs may be hierarchical.  For example, if a KBase genome\nidentifier is \"kb|g.1234\", a protein encoding gene within that genome may be represented as\n\"kb|g.1234.peg.771\".",
              "module" : "Tree",
              "name" : "kbase_id"
            }
          }
        }
      } ]
    }, {
      "!" : "Bio::KBase::KIDL::KBT::Funcdef",
      "annotations" : {
        "unknown_annotations" : { }
      },
      "async" : "0",
      "authentication" : "none",
      "comment" : "Given a tree id, this method returns a mapping from a tree's unique internal ID to\na protein sequence ID.",
      "name" : "get_leaf_to_protein_map",
      "parameters" : [ {
        "name" : "tree_id",
        "type" : {
          "!" : "Bio::KBase::KIDL::KBT::Typedef",
          "alias_type" : {
            "!" : "Bio::KBase::KIDL::KBT::Scalar",
            "annotations" : { },
            "scalar_type" : "string"
          },
          "annotations" : {
            "metadata" : { },
            "searchable_ws_subset" : { },
            "unknown_annotations" : { }
          },
          "comment" : "A KBase ID is a string starting with the characters \"kb|\".  KBase IDs are typed. The types are\ndesignated using a short string. For instance,\" g\" denotes a genome, \"tree\" denotes a Tree, and\n\"aln\" denotes a sequence alignment. KBase IDs may be hierarchical.  For example, if a KBase genome\nidentifier is \"kb|g.1234\", a protein encoding gene within that genome may be represented as\n\"kb|g.1234.peg.771\".",
          "module" : "Tree",
          "name" : "kbase_id"
        }
      } ],
      "return_type" : [ {
        "type" : {
          "!" : "Bio::KBase::KIDL::KBT::Mapping",
          "annotations" : { },
          "key_type" : {
            "!" : "Bio::KBase::KIDL::KBT::Typedef",
            "alias_type" : {
              "!" : "Bio::KBase::KIDL::KBT::Scalar",
              "annotations" : { },
              "scalar_type" : "string"
            },
            "annotations" : {
              "metadata" : { },
              "searchable_ws_subset" : { },
              "unknown_annotations" : { }
            },
            "comment" : "A KBase ID is a string starting with the characters \"kb|\".  KBase IDs are typed. The types are\ndesignated using a short string. For instance,\" g\" denotes a genome, \"tree\" denotes a Tree, and\n\"aln\" denotes a sequence alignment. KBase IDs may be hierarchical.  For example, if a KBase genome\nidentifier is \"kb|g.1234\", a protein encoding gene within that genome may be represented as\n\"kb|g.1234.peg.771\".",
            "module" : "Tree",
            "name" : "kbase_id"
          },
          "value_type" : {
            "!" : "Bio::KBase::KIDL::KBT::Typedef",
            "alias_type" : {
              "!" : "Bio::KBase::KIDL::KBT::Scalar",
              "annotations" : { },
              "scalar_type" : "string"
            },
            "annotations" : {
              "metadata" : { },
              "searchable_ws_subset" : { },
              "unknown_annotations" : { }
            },
            "comment" : "A KBase ID is a string starting with the characters \"kb|\".  KBase IDs are typed. The types are\ndesignated using a short string. For instance,\" g\" denotes a genome, \"tree\" denotes a Tree, and\n\"aln\" denotes a sequence alignment. KBase IDs may be hierarchical.  For example, if a KBase genome\nidentifier is \"kb|g.1234\", a protein encoding gene within that genome may be represented as\n\"kb|g.1234.peg.771\".",
            "module" : "Tree",
            "name" : "kbase_id"
          }
        }
      } ]
    }, {
      "!" : "Bio::KBase::KIDL::KBT::Funcdef",
      "annotations" : {
        "unknown_annotations" : { }
      },
      "async" : "0",
      "authentication" : "none",
      "comment" : "Given a tree id, this method returns a mapping from a tree's unique internal ID to\na KBase feature ID if and only if a cannonical feature id exists.",
      "name" : "get_leaf_to_feature_map",
      "parameters" : [ {
        "name" : "tree_id",
        "type" : {
          "!" : "Bio::KBase::KIDL::KBT::Typedef",
          "alias_type" : {
            "!" : "Bio::KBase::KIDL::KBT::Scalar",
            "annotations" : { },
            "scalar_type" : "string"
          },
          "annotations" : {
            "metadata" : { },
            "searchable_ws_subset" : { },
            "unknown_annotations" : { }
          },
          "comment" : "A KBase ID is a string starting with the characters \"kb|\".  KBase IDs are typed. The types are\ndesignated using a short string. For instance,\" g\" denotes a genome, \"tree\" denotes a Tree, and\n\"aln\" denotes a sequence alignment. KBase IDs may be hierarchical.  For example, if a KBase genome\nidentifier is \"kb|g.1234\", a protein encoding gene within that genome may be represented as\n\"kb|g.1234.peg.771\".",
          "module" : "Tree",
          "name" : "kbase_id"
        }
      } ],
      "return_type" : [ {
        "type" : {
          "!" : "Bio::KBase::KIDL::KBT::Mapping",
          "annotations" : { },
          "key_type" : {
            "!" : "Bio::KBase::KIDL::KBT::Typedef",
            "alias_type" : {
              "!" : "Bio::KBase::KIDL::KBT::Scalar",
              "annotations" : { },
              "scalar_type" : "string"
            },
            "annotations" : {
              "metadata" : { },
              "searchable_ws_subset" : { },
              "unknown_annotations" : { }
            },
            "comment" : "A KBase ID is a string starting with the characters \"kb|\".  KBase IDs are typed. The types are\ndesignated using a short string. For instance,\" g\" denotes a genome, \"tree\" denotes a Tree, and\n\"aln\" denotes a sequence alignment. KBase IDs may be hierarchical.  For example, if a KBase genome\nidentifier is \"kb|g.1234\", a protein encoding gene within that genome may be represented as\n\"kb|g.1234.peg.771\".",
            "module" : "Tree",
            "name" : "kbase_id"
          },
          "value_type" : {
            "!" : "Bio::KBase::KIDL::KBT::Typedef",
            "alias_type" : {
              "!" : "Bio::KBase::KIDL::KBT::Scalar",
              "annotations" : { },
              "scalar_type" : "string"
            },
            "annotations" : {
              "metadata" : { },
              "searchable_ws_subset" : { },
              "unknown_annotations" : { }
            },
            "comment" : "A KBase ID is a string starting with the characters \"kb|\".  KBase IDs are typed. The types are\ndesignated using a short string. For instance,\" g\" denotes a genome, \"tree\" denotes a Tree, and\n\"aln\" denotes a sequence alignment. KBase IDs may be hierarchical.  For example, if a KBase genome\nidentifier is \"kb|g.1234\", a protein encoding gene within that genome may be represented as\n\"kb|g.1234.peg.771\".",
            "module" : "Tree",
            "name" : "kbase_id"
          }
        }
      } ]
    }, {
      "!" : "Bio::KBase::KIDL::KBT::Typedef",
      "alias_type" : {
        "!" : "Bio::KBase::KIDL::KBT::Struct",
        "annotations" : {
          "metadata" : { },
          "searchable_ws_subset" : { }
        },
        "comment" : "Structure to group input parameters to the compute_abundance_profile method.\n\n    kbase_id tree_id                - the KBase ID of the tree to compute abundances for; the tree is\n                                      used to identify the set of sequences that were aligned to build\n                                      the tree; each leaf node of a tree built from an alignment will\n                                      be mapped to a sequence; the compute_abundance_profile method\n                                      assumes that trees are built from protein sequences\n    string protein_family_name      - the name of the protein family used to pull a small set of reads\n                                      from a metagenomic sample; currently only COG families are supported\n    string protein_family_source    - the name of the source of the protein family; currently supported\n                                      protein families are: 'COG'\n    string metagenomic_sample_id    - the ID of the metagenomic sample to lookup; see the KBase communities\n                                      service to identifiy metagenomic samples\n    int percent_identity_threshold  - the minimum acceptable percent identity for hits, provided as a percentage\n                                      and not a fraction (i.e. set to 87.5 for 87.5%)\n    int match_length_threshold      - the minimum acceptable length of a match to consider a hit",
        "items" : [ {
          "!" : "Bio::KBase::KIDL::KBT::StructItem",
          "item_type" : {
            "!" : "Bio::KBase::KIDL::KBT::Typedef",
            "alias_type" : {
              "!" : "Bio::KBase::KIDL::KBT::Scalar",
              "annotations" : { },
              "scalar_type" : "string"
            },
            "annotations" : {
              "metadata" : { },
              "searchable_ws_subset" : { },
              "unknown_annotations" : { }
            },
            "comment" : "A KBase ID is a string starting with the characters \"kb|\".  KBase IDs are typed. The types are\ndesignated using a short string. For instance,\" g\" denotes a genome, \"tree\" denotes a Tree, and\n\"aln\" denotes a sequence alignment. KBase IDs may be hierarchical.  For example, if a KBase genome\nidentifier is \"kb|g.1234\", a protein encoding gene within that genome may be represented as\n\"kb|g.1234.peg.771\".",
            "module" : "Tree",
            "name" : "kbase_id"
          },
          "name" : "tree_id",
          "nullable" : "0"
        }, {
          "!" : "Bio::KBase::KIDL::KBT::StructItem",
          "item_type" : {
            "!" : "Bio::KBase::KIDL::KBT::Scalar",
            "annotations" : { },
            "scalar_type" : "string"
          },
          "name" : "protein_family_name",
          "nullable" : "0"
        }, {
          "!" : "Bio::KBase::KIDL::KBT::StructItem",
          "item_type" : {
            "!" : "Bio::KBase::KIDL::KBT::Scalar",
            "annotations" : { },
            "scalar_type" : "string"
          },
          "name" : "protein_family_source",
          "nullable" : "0"
        }, {
          "!" : "Bio::KBase::KIDL::KBT::StructItem",
          "item_type" : {
            "!" : "Bio::KBase::KIDL::KBT::Scalar",
            "annotations" : { },
            "scalar_type" : "string"
          },
          "name" : "metagenomic_sample_id",
          "nullable" : "0"
        }, {
          "!" : "Bio::KBase::KIDL::KBT::StructItem",
          "item_type" : {
            "!" : "Bio::KBase::KIDL::KBT::Scalar",
            "annotations" : { },
            "scalar_type" : "int"
          },
          "name" : "percent_identity_threshold",
          "nullable" : "0"
        }, {
          "!" : "Bio::KBase::KIDL::KBT::StructItem",
          "item_type" : {
            "!" : "Bio::KBase::KIDL::KBT::Scalar",
            "annotations" : { },
            "scalar_type" : "int"
          },
          "name" : "match_length_threshold",
          "nullable" : "0"
        }, {
          "!" : "Bio::KBase::KIDL::KBT::StructItem",
          "item_type" : {
            "!" : "Bio::KBase::KIDL::KBT::Scalar",
            "annotations" : { },
            "scalar_type" : "string"
          },
          "name" : "mg_auth_key",
          "nullable" : "0"
        } ],
        "module" : "Tree",
        "name" : "abundance_params"
      },
      "annotations" : {
        "metadata" : { },
        "searchable_ws_subset" : { },
        "unknown_annotations" : { }
      },
      "comment" : "Structure to group input parameters to the compute_abundance_profile method.\n\n    kbase_id tree_id                - the KBase ID of the tree to compute abundances for; the tree is\n                                      used to identify the set of sequences that were aligned to build\n                                      the tree; each leaf node of a tree built from an alignment will\n                                      be mapped to a sequence; the compute_abundance_profile method\n                                      assumes that trees are built from protein sequences\n    string protein_family_name      - the name of the protein family used to pull a small set of reads\n                                      from a metagenomic sample; currently only COG families are supported\n    string protein_family_source    - the name of the source of the protein family; currently supported\n                                      protein families are: 'COG'\n    string metagenomic_sample_id    - the ID of the metagenomic sample to lookup; see the KBase communities\n                                      service to identifiy metagenomic samples\n    int percent_identity_threshold  - the minimum acceptable percent identity for hits, provided as a percentage\n                                      and not a fraction (i.e. set to 87.5 for 87.5%)\n    int match_length_threshold      - the minimum acceptable length of a match to consider a hit",
      "module" : "Tree",
      "name" : "abundance_params"
    }, {
      "!" : "Bio::KBase::KIDL::KBT::Typedef",
      "alias_type" : {
        "!" : "Bio::KBase::KIDL::KBT::Struct",
        "annotations" : {
          "metadata" : { },
          "searchable_ws_subset" : { }
        },
        "comment" : "Structure to group output of the compute_abundance_profile method.\n\n    mapping <string,int> abundances - maps the raw row ID of each leaf node in the input tree to the number\n                                      of hits that map to the given leaf; only row IDs with 1 or more hits\n                                      are added to this map, thus missing leaf nodes imply 0 hits\n    int n_hits                      - the total number of hits in this sample to any leaf\n    int n_reads                     - the total number of reads that were identified for the input protein\n                                      family; if the protein family could not be found this will be zero.",
        "items" : [ {
          "!" : "Bio::KBase::KIDL::KBT::StructItem",
          "item_type" : {
            "!" : "Bio::KBase::KIDL::KBT::Mapping",
            "annotations" : { },
            "key_type" : {
              "!" : "Bio::KBase::KIDL::KBT::Scalar",
              "annotations" : { },
              "scalar_type" : "string"
            },
            "value_type" : {
              "!" : "Bio::KBase::KIDL::KBT::Scalar",
              "annotations" : { },
              "scalar_type" : "int"
            }
          },
          "name" : "abundances",
          "nullable" : "0"
        }, {
          "!" : "Bio::KBase::KIDL::KBT::StructItem",
          "item_type" : {
            "!" : "Bio::KBase::KIDL::KBT::Scalar",
            "annotations" : { },
            "scalar_type" : "int"
          },
          "name" : "n_hits",
          "nullable" : "0"
        }, {
          "!" : "Bio::KBase::KIDL::KBT::StructItem",
          "item_type" : {
            "!" : "Bio::KBase::KIDL::KBT::Scalar",
            "annotations" : { },
            "scalar_type" : "int"
          },
          "name" : "n_reads",
          "nullable" : "0"
        } ],
        "module" : "Tree",
        "name" : "abundance_result"
      },
      "annotations" : {
        "metadata" : { },
        "searchable_ws_subset" : { },
        "unknown_annotations" : { }
      },
      "comment" : "Structure to group output of the compute_abundance_profile method.\n\n    mapping <string,int> abundances - maps the raw row ID of each leaf node in the input tree to the number\n                                      of hits that map to the given leaf; only row IDs with 1 or more hits\n                                      are added to this map, thus missing leaf nodes imply 0 hits\n    int n_hits                      - the total number of hits in this sample to any leaf\n    int n_reads                     - the total number of reads that were identified for the input protein\n                                      family; if the protein family could not be found this will be zero.",
      "module" : "Tree",
      "name" : "abundance_result"
    }, {
      "!" : "Bio::KBase::KIDL::KBT::Funcdef",
      "annotations" : {
        "unknown_annotations" : { }
      },
      "async" : "0",
      "authentication" : "none",
      "comment" : "Given an input KBase tree built from a sequence alignment, a metagenomic sample, and a protein family, this method\nwill tabulate the number of reads that match to every leaf of the input tree.  First, a set of assembled reads from\na metagenomic sample are pulled from the KBase communities service which have been determined to be a likely hit\nto the specified protein family.  Second, the sequences aligned to generate the tree are retrieved.  Third, UCLUST [1]\nis used to map reads to target sequences of the tree.  Finally, for each leaf in the tree, the number of hits matching\nthe input search criteria is tabulated and returned.  See the defined objects 'abundance_params' and 'abundance_result'\nfor additional details on specifying the input parameters and handling the results.\n\n[1] Edgar, R.C. (2010) Search and clustering orders of magnitude faster than BLAST, Bioinformatics 26(19), 2460-2461.",
      "name" : "compute_abundance_profile",
      "parameters" : [ {
        "name" : "abundance_params",
        "type" : {
          "!" : "Bio::KBase::KIDL::KBT::Typedef",
          "alias_type" : {
            "!" : "Bio::KBase::KIDL::KBT::Struct",
            "annotations" : {
              "metadata" : { },
              "searchable_ws_subset" : { }
            },
            "comment" : "Structure to group input parameters to the compute_abundance_profile method.\n\n    kbase_id tree_id                - the KBase ID of the tree to compute abundances for; the tree is\n                                      used to identify the set of sequences that were aligned to build\n                                      the tree; each leaf node of a tree built from an alignment will\n                                      be mapped to a sequence; the compute_abundance_profile method\n                                      assumes that trees are built from protein sequences\n    string protein_family_name      - the name of the protein family used to pull a small set of reads\n                                      from a metagenomic sample; currently only COG families are supported\n    string protein_family_source    - the name of the source of the protein family; currently supported\n                                      protein families are: 'COG'\n    string metagenomic_sample_id    - the ID of the metagenomic sample to lookup; see the KBase communities\n                                      service to identifiy metagenomic samples\n    int percent_identity_threshold  - the minimum acceptable percent identity for hits, provided as a percentage\n                                      and not a fraction (i.e. set to 87.5 for 87.5%)\n    int match_length_threshold      - the minimum acceptable length of a match to consider a hit",
            "items" : [ {
              "!" : "Bio::KBase::KIDL::KBT::StructItem",
              "item_type" : {
                "!" : "Bio::KBase::KIDL::KBT::Typedef",
                "alias_type" : {
                  "!" : "Bio::KBase::KIDL::KBT::Scalar",
                  "annotations" : { },
                  "scalar_type" : "string"
                },
                "annotations" : {
                  "metadata" : { },
                  "searchable_ws_subset" : { },
                  "unknown_annotations" : { }
                },
                "comment" : "A KBase ID is a string starting with the characters \"kb|\".  KBase IDs are typed. The types are\ndesignated using a short string. For instance,\" g\" denotes a genome, \"tree\" denotes a Tree, and\n\"aln\" denotes a sequence alignment. KBase IDs may be hierarchical.  For example, if a KBase genome\nidentifier is \"kb|g.1234\", a protein encoding gene within that genome may be represented as\n\"kb|g.1234.peg.771\".",
                "module" : "Tree",
                "name" : "kbase_id"
              },
              "name" : "tree_id",
              "nullable" : "0"
            }, {
              "!" : "Bio::KBase::KIDL::KBT::StructItem",
              "item_type" : {
                "!" : "Bio::KBase::KIDL::KBT::Scalar",
                "annotations" : { },
                "scalar_type" : "string"
              },
              "name" : "protein_family_name",
              "nullable" : "0"
            }, {
              "!" : "Bio::KBase::KIDL::KBT::StructItem",
              "item_type" : {
                "!" : "Bio::KBase::KIDL::KBT::Scalar",
                "annotations" : { },
                "scalar_type" : "string"
              },
              "name" : "protein_family_source",
              "nullable" : "0"
            }, {
              "!" : "Bio::KBase::KIDL::KBT::StructItem",
              "item_type" : {
                "!" : "Bio::KBase::KIDL::KBT::Scalar",
                "annotations" : { },
                "scalar_type" : "string"
              },
              "name" : "metagenomic_sample_id",
              "nullable" : "0"
            }, {
              "!" : "Bio::KBase::KIDL::KBT::StructItem",
              "item_type" : {
                "!" : "Bio::KBase::KIDL::KBT::Scalar",
                "annotations" : { },
                "scalar_type" : "int"
              },
              "name" : "percent_identity_threshold",
              "nullable" : "0"
            }, {
              "!" : "Bio::KBase::KIDL::KBT::StructItem",
              "item_type" : {
                "!" : "Bio::KBase::KIDL::KBT::Scalar",
                "annotations" : { },
                "scalar_type" : "int"
              },
              "name" : "match_length_threshold",
              "nullable" : "0"
            }, {
              "!" : "Bio::KBase::KIDL::KBT::StructItem",
              "item_type" : {
                "!" : "Bio::KBase::KIDL::KBT::Scalar",
                "annotations" : { },
                "scalar_type" : "string"
              },
              "name" : "mg_auth_key",
              "nullable" : "0"
            } ],
            "module" : "Tree",
            "name" : "abundance_params"
          },
          "annotations" : {
            "metadata" : { },
            "searchable_ws_subset" : { },
            "unknown_annotations" : { }
          },
          "comment" : "Structure to group input parameters to the compute_abundance_profile method.\n\n    kbase_id tree_id                - the KBase ID of the tree to compute abundances for; the tree is\n                                      used to identify the set of sequences that were aligned to build\n                                      the tree; each leaf node of a tree built from an alignment will\n                                      be mapped to a sequence; the compute_abundance_profile method\n                                      assumes that trees are built from protein sequences\n    string protein_family_name      - the name of the protein family used to pull a small set of reads\n                                      from a metagenomic sample; currently only COG families are supported\n    string protein_family_source    - the name of the source of the protein family; currently supported\n                                      protein families are: 'COG'\n    string metagenomic_sample_id    - the ID of the metagenomic sample to lookup; see the KBase communities\n                                      service to identifiy metagenomic samples\n    int percent_identity_threshold  - the minimum acceptable percent identity for hits, provided as a percentage\n                                      and not a fraction (i.e. set to 87.5 for 87.5%)\n    int match_length_threshold      - the minimum acceptable length of a match to consider a hit",
          "module" : "Tree",
          "name" : "abundance_params"
        }
      } ],
      "return_type" : [ {
        "name" : "abundance_result",
        "type" : {
          "!" : "Bio::KBase::KIDL::KBT::Typedef",
          "alias_type" : {
            "!" : "Bio::KBase::KIDL::KBT::Struct",
            "annotations" : {
              "metadata" : { },
              "searchable_ws_subset" : { }
            },
            "comment" : "Structure to group output of the compute_abundance_profile method.\n\n    mapping <string,int> abundances - maps the raw row ID of each leaf node in the input tree to the number\n                                      of hits that map to the given leaf; only row IDs with 1 or more hits\n                                      are added to this map, thus missing leaf nodes imply 0 hits\n    int n_hits                      - the total number of hits in this sample to any leaf\n    int n_reads                     - the total number of reads that were identified for the input protein\n                                      family; if the protein family could not be found this will be zero.",
            "items" : [ {
              "!" : "Bio::KBase::KIDL::KBT::StructItem",
              "item_type" : {
                "!" : "Bio::KBase::KIDL::KBT::Mapping",
                "annotations" : { },
                "key_type" : {
                  "!" : "Bio::KBase::KIDL::KBT::Scalar",
                  "annotations" : { },
                  "scalar_type" : "string"
                },
                "value_type" : {
                  "!" : "Bio::KBase::KIDL::KBT::Scalar",
                  "annotations" : { },
                  "scalar_type" : "int"
                }
              },
              "name" : "abundances",
              "nullable" : "0"
            }, {
              "!" : "Bio::KBase::KIDL::KBT::StructItem",
              "item_type" : {
                "!" : "Bio::KBase::KIDL::KBT::Scalar",
                "annotations" : { },
                "scalar_type" : "int"
              },
              "name" : "n_hits",
              "nullable" : "0"
            }, {
              "!" : "Bio::KBase::KIDL::KBT::StructItem",
              "item_type" : {
                "!" : "Bio::KBase::KIDL::KBT::Scalar",
                "annotations" : { },
                "scalar_type" : "int"
              },
              "name" : "n_reads",
              "nullable" : "0"
            } ],
            "module" : "Tree",
            "name" : "abundance_result"
          },
          "annotations" : {
            "metadata" : { },
            "searchable_ws_subset" : { },
            "unknown_annotations" : { }
          },
          "comment" : "Structure to group output of the compute_abundance_profile method.\n\n    mapping <string,int> abundances - maps the raw row ID of each leaf node in the input tree to the number\n                                      of hits that map to the given leaf; only row IDs with 1 or more hits\n                                      are added to this map, thus missing leaf nodes imply 0 hits\n    int n_hits                      - the total number of hits in this sample to any leaf\n    int n_reads                     - the total number of reads that were identified for the input protein\n                                      family; if the protein family could not be found this will be zero.",
          "module" : "Tree",
          "name" : "abundance_result"
        }
      } ]
    }, {
      "!" : "Bio::KBase::KIDL::KBT::Funcdef",
      "annotations" : {
        "unknown_annotations" : { }
      },
      "async" : "0",
      "authentication" : "none",
      "comment" : "Given a tree structure in newick, render it in HTML/JAVASCRIPT and return the page as a string. display_options\nprovides a way to pass parameters to the tree rendering algorithm, but currently no options are recognized.",
      "name" : "draw_html_tree",
      "parameters" : [ {
        "name" : "tree",
        "type" : {
          "!" : "Bio::KBase::KIDL::KBT::Typedef",
          "alias_type" : {
            "!" : "Bio::KBase::KIDL::KBT::Typedef",
            "alias_type" : {
              "!" : "Bio::KBase::KIDL::KBT::Scalar",
              "annotations" : { },
              "scalar_type" : "string"
            },
            "annotations" : {
              "metadata" : { },
              "searchable_ws_subset" : { },
              "unknown_annotations" : { }
            },
            "comment" : "A string representation of a phylogenetic tree.  The format/syntax of the string is\nspecified by using one of the available typedefs declaring a particular format, such as 'newick_tree',\n'phyloXML_tree' or 'json_tree'.  When a format is not explictily specified, it is possible to return\ntrees in different formats depending on addtional parameters. Regardless of format, all leaf nodes\nin trees built from MSAs are indexed to a specific MSA row.  You can use the appropriate functionality\nof the API to replace these IDs with other KBase Ids instead. Internal nodes may or may not be named.\nNodes, depending on the format, may also be annotated with structured data such as bootstrap values and\ndistances.",
            "module" : "Tree",
            "name" : "tree"
          },
          "annotations" : {
            "metadata" : { },
            "searchable_ws_subset" : { },
            "unknown_annotations" : { }
          },
          "comment" : "Trees are represented in KBase by default in newick format (http://en.wikipedia.org/wiki/Newick_format)\nand are returned to you in this format by default.",
          "module" : "Tree",
          "name" : "newick_tree"
        }
      }, {
        "name" : "display_options",
        "type" : {
          "!" : "Bio::KBase::KIDL::KBT::Mapping",
          "annotations" : { },
          "key_type" : {
            "!" : "Bio::KBase::KIDL::KBT::Scalar",
            "annotations" : { },
            "scalar_type" : "string"
          },
          "value_type" : {
            "!" : "Bio::KBase::KIDL::KBT::Scalar",
            "annotations" : { },
            "scalar_type" : "string"
          }
        }
      } ],
      "return_type" : [ {
        "type" : {
          "!" : "Bio::KBase::KIDL::KBT::Typedef",
          "alias_type" : {
            "!" : "Bio::KBase::KIDL::KBT::Scalar",
            "annotations" : { },
            "scalar_type" : "string"
          },
          "annotations" : {
            "metadata" : { },
            "searchable_ws_subset" : { },
            "unknown_annotations" : { }
          },
          "comment" : "String in HTML format, used in the KBase Tree library for returning rendered trees.",
          "module" : "Tree",
          "name" : "html_file"
        }
      } ]
    } ],
    "module_name" : "Tree",
    "options" : [ ],
    "service_name" : "Tree"
  }, [ ], {
    "UnspecifiedObject" : {
      "!" : "Bio::KBase::KIDL::KBT::UnspecifiedObject",
      "annotations" : { }
    },
    "abundance_params" : {
      "!" : "Bio::KBase::KIDL::KBT::Typedef",
      "alias_type" : {
        "!" : "Bio::KBase::KIDL::KBT::Struct",
        "annotations" : {
          "metadata" : { },
          "searchable_ws_subset" : { }
        },
        "comment" : "Structure to group input parameters to the compute_abundance_profile method.\n\n    kbase_id tree_id                - the KBase ID of the tree to compute abundances for; the tree is\n                                      used to identify the set of sequences that were aligned to build\n                                      the tree; each leaf node of a tree built from an alignment will\n                                      be mapped to a sequence; the compute_abundance_profile method\n                                      assumes that trees are built from protein sequences\n    string protein_family_name      - the name of the protein family used to pull a small set of reads\n                                      from a metagenomic sample; currently only COG families are supported\n    string protein_family_source    - the name of the source of the protein family; currently supported\n                                      protein families are: 'COG'\n    string metagenomic_sample_id    - the ID of the metagenomic sample to lookup; see the KBase communities\n                                      service to identifiy metagenomic samples\n    int percent_identity_threshold  - the minimum acceptable percent identity for hits, provided as a percentage\n                                      and not a fraction (i.e. set to 87.5 for 87.5%)\n    int match_length_threshold      - the minimum acceptable length of a match to consider a hit",
        "items" : [ {
          "!" : "Bio::KBase::KIDL::KBT::StructItem",
          "item_type" : {
            "!" : "Bio::KBase::KIDL::KBT::Typedef",
            "alias_type" : {
              "!" : "Bio::KBase::KIDL::KBT::Scalar",
              "annotations" : { },
              "scalar_type" : "string"
            },
            "annotations" : {
              "metadata" : { },
              "searchable_ws_subset" : { },
              "unknown_annotations" : { }
            },
            "comment" : "A KBase ID is a string starting with the characters \"kb|\".  KBase IDs are typed. The types are\ndesignated using a short string. For instance,\" g\" denotes a genome, \"tree\" denotes a Tree, and\n\"aln\" denotes a sequence alignment. KBase IDs may be hierarchical.  For example, if a KBase genome\nidentifier is \"kb|g.1234\", a protein encoding gene within that genome may be represented as\n\"kb|g.1234.peg.771\".",
            "module" : "Tree",
            "name" : "kbase_id"
          },
          "name" : "tree_id",
          "nullable" : "0"
        }, {
          "!" : "Bio::KBase::KIDL::KBT::StructItem",
          "item_type" : {
            "!" : "Bio::KBase::KIDL::KBT::Scalar",
            "annotations" : { },
            "scalar_type" : "string"
          },
          "name" : "protein_family_name",
          "nullable" : "0"
        }, {
          "!" : "Bio::KBase::KIDL::KBT::StructItem",
          "item_type" : {
            "!" : "Bio::KBase::KIDL::KBT::Scalar",
            "annotations" : { },
            "scalar_type" : "string"
          },
          "name" : "protein_family_source",
          "nullable" : "0"
        }, {
          "!" : "Bio::KBase::KIDL::KBT::StructItem",
          "item_type" : {
            "!" : "Bio::KBase::KIDL::KBT::Scalar",
            "annotations" : { },
            "scalar_type" : "string"
          },
          "name" : "metagenomic_sample_id",
          "nullable" : "0"
        }, {
          "!" : "Bio::KBase::KIDL::KBT::StructItem",
          "item_type" : {
            "!" : "Bio::KBase::KIDL::KBT::Scalar",
            "annotations" : { },
            "scalar_type" : "int"
          },
          "name" : "percent_identity_threshold",
          "nullable" : "0"
        }, {
          "!" : "Bio::KBase::KIDL::KBT::StructItem",
          "item_type" : {
            "!" : "Bio::KBase::KIDL::KBT::Scalar",
            "annotations" : { },
            "scalar_type" : "int"
          },
          "name" : "match_length_threshold",
          "nullable" : "0"
        }, {
          "!" : "Bio::KBase::KIDL::KBT::StructItem",
          "item_type" : {
            "!" : "Bio::KBase::KIDL::KBT::Scalar",
            "annotations" : { },
            "scalar_type" : "string"
          },
          "name" : "mg_auth_key",
          "nullable" : "0"
        } ],
        "module" : "Tree",
        "name" : "abundance_params"
      },
      "annotations" : {
        "metadata" : { },
        "searchable_ws_subset" : { },
        "unknown_annotations" : { }
      },
      "comment" : "Structure to group input parameters to the compute_abundance_profile method.\n\n    kbase_id tree_id                - the KBase ID of the tree to compute abundances for; the tree is\n                                      used to identify the set of sequences that were aligned to build\n                                      the tree; each leaf node of a tree built from an alignment will\n                                      be mapped to a sequence; the compute_abundance_profile method\n                                      assumes that trees are built from protein sequences\n    string protein_family_name      - the name of the protein family used to pull a small set of reads\n                                      from a metagenomic sample; currently only COG families are supported\n    string protein_family_source    - the name of the source of the protein family; currently supported\n                                      protein families are: 'COG'\n    string metagenomic_sample_id    - the ID of the metagenomic sample to lookup; see the KBase communities\n                                      service to identifiy metagenomic samples\n    int percent_identity_threshold  - the minimum acceptable percent identity for hits, provided as a percentage\n                                      and not a fraction (i.e. set to 87.5 for 87.5%)\n    int match_length_threshold      - the minimum acceptable length of a match to consider a hit",
      "module" : "Tree",
      "name" : "abundance_params"
    },
    "abundance_result" : {
      "!" : "Bio::KBase::KIDL::KBT::Typedef",
      "alias_type" : {
        "!" : "Bio::KBase::KIDL::KBT::Struct",
        "annotations" : {
          "metadata" : { },
          "searchable_ws_subset" : { }
        },
        "comment" : "Structure to group output of the compute_abundance_profile method.\n\n    mapping <string,int> abundances - maps the raw row ID of each leaf node in the input tree to the number\n                                      of hits that map to the given leaf; only row IDs with 1 or more hits\n                                      are added to this map, thus missing leaf nodes imply 0 hits\n    int n_hits                      - the total number of hits in this sample to any leaf\n    int n_reads                     - the total number of reads that were identified for the input protein\n                                      family; if the protein family could not be found this will be zero.",
        "items" : [ {
          "!" : "Bio::KBase::KIDL::KBT::StructItem",
          "item_type" : {
            "!" : "Bio::KBase::KIDL::KBT::Mapping",
            "annotations" : { },
            "key_type" : {
              "!" : "Bio::KBase::KIDL::KBT::Scalar",
              "annotations" : { },
              "scalar_type" : "string"
            },
            "value_type" : {
              "!" : "Bio::KBase::KIDL::KBT::Scalar",
              "annotations" : { },
              "scalar_type" : "int"
            }
          },
          "name" : "abundances",
          "nullable" : "0"
        }, {
          "!" : "Bio::KBase::KIDL::KBT::StructItem",
          "item_type" : {
            "!" : "Bio::KBase::KIDL::KBT::Scalar",
            "annotations" : { },
            "scalar_type" : "int"
          },
          "name" : "n_hits",
          "nullable" : "0"
        }, {
          "!" : "Bio::KBase::KIDL::KBT::StructItem",
          "item_type" : {
            "!" : "Bio::KBase::KIDL::KBT::Scalar",
            "annotations" : { },
            "scalar_type" : "int"
          },
          "name" : "n_reads",
          "nullable" : "0"
        } ],
        "module" : "Tree",
        "name" : "abundance_result"
      },
      "annotations" : {
        "metadata" : { },
        "searchable_ws_subset" : { },
        "unknown_annotations" : { }
      },
      "comment" : "Structure to group output of the compute_abundance_profile method.\n\n    mapping <string,int> abundances - maps the raw row ID of each leaf node in the input tree to the number\n                                      of hits that map to the given leaf; only row IDs with 1 or more hits\n                                      are added to this map, thus missing leaf nodes imply 0 hits\n    int n_hits                      - the total number of hits in this sample to any leaf\n    int n_reads                     - the total number of reads that were identified for the input protein\n                                      family; if the protein family could not be found this will be zero.",
      "module" : "Tree",
      "name" : "abundance_result"
    },
    "alignment" : {
      "!" : "Bio::KBase::KIDL::KBT::Typedef",
      "alias_type" : {
        "!" : "Bio::KBase::KIDL::KBT::Scalar",
        "annotations" : { },
        "scalar_type" : "string"
      },
      "annotations" : {
        "metadata" : { },
        "searchable_ws_subset" : { },
        "unknown_annotations" : { }
      },
      "comment" : "String representation of a sequence alignment, the format of which may be different depending on\ninput options for retrieving the alignment.",
      "module" : "Tree",
      "name" : "alignment"
    },
    "alignment_meta_data" : {
      "!" : "Bio::KBase::KIDL::KBT::Typedef",
      "alias_type" : {
        "!" : "Bio::KBase::KIDL::KBT::Struct",
        "annotations" : {
          "metadata" : { },
          "searchable_ws_subset" : { }
        },
        "comment" : "Meta data associated with an alignment.\n\n    list<kbase_id> tree_ids - the set of trees that were built from this alignment\n    string status - set to 'active' if this is the latest alignment for a particular set of sequences\n    string sequence_type - indicates what type of sequence is aligned (e.g. protein vs. dna)\n    bool is_concatenation - true if the alignment is based on the concatenation of multiple non-contiguous\n                            sequences, false if each row cooresponds to exactly one sequence (possibly with gaps)\n    timestamp date_created - time at which the alignment was built/loaded in seconds since the epoch\n    int n_rows - number of rows in the alignment\n    int n_cols - number of columns in the alignment\n    string alignment_construction_method - the name of the software tool used to build the alignment\n    string alignment_construction_parameters - set of non-default parameters used to construct the alignment\n    string alignment_protocol - simple free-form text which may provide additional details of how the alignment was built\n    string source_db - the source database where this alignment originated, if one exists\n    string source_id - the id of this alignment in an external database, if one exists",
        "items" : [ {
          "!" : "Bio::KBase::KIDL::KBT::StructItem",
          "item_type" : {
            "!" : "Bio::KBase::KIDL::KBT::List",
            "annotations" : { },
            "element_type" : {
              "!" : "Bio::KBase::KIDL::KBT::Typedef",
              "alias_type" : {
                "!" : "Bio::KBase::KIDL::KBT::Scalar",
                "annotations" : { },
                "scalar_type" : "string"
              },
              "annotations" : {
                "metadata" : { },
                "searchable_ws_subset" : { },
                "unknown_annotations" : { }
              },
              "comment" : "A KBase ID is a string starting with the characters \"kb|\".  KBase IDs are typed. The types are\ndesignated using a short string. For instance,\" g\" denotes a genome, \"tree\" denotes a Tree, and\n\"aln\" denotes a sequence alignment. KBase IDs may be hierarchical.  For example, if a KBase genome\nidentifier is \"kb|g.1234\", a protein encoding gene within that genome may be represented as\n\"kb|g.1234.peg.771\".",
              "module" : "Tree",
              "name" : "kbase_id"
            }
          },
          "name" : "tree_ids",
          "nullable" : "0"
        }, {
          "!" : "Bio::KBase::KIDL::KBT::StructItem",
          "item_type" : {
            "!" : "Bio::KBase::KIDL::KBT::Scalar",
            "annotations" : { },
            "scalar_type" : "string"
          },
          "name" : "status",
          "nullable" : "0"
        }, {
          "!" : "Bio::KBase::KIDL::KBT::StructItem",
          "item_type" : {
            "!" : "Bio::KBase::KIDL::KBT::Scalar",
            "annotations" : { },
            "scalar_type" : "string"
          },
          "name" : "sequence_type",
          "nullable" : "0"
        }, {
          "!" : "Bio::KBase::KIDL::KBT::StructItem",
          "item_type" : {
            "!" : "Bio::KBase::KIDL::KBT::Scalar",
            "annotations" : { },
            "scalar_type" : "string"
          },
          "name" : "is_concatenation",
          "nullable" : "0"
        }, {
          "!" : "Bio::KBase::KIDL::KBT::StructItem",
          "item_type" : {
            "!" : "Bio::KBase::KIDL::KBT::Typedef",
            "alias_type" : {
              "!" : "Bio::KBase::KIDL::KBT::Scalar",
              "annotations" : { },
              "scalar_type" : "string"
            },
            "annotations" : {
              "metadata" : { },
              "searchable_ws_subset" : { },
              "unknown_annotations" : { }
            },
            "comment" : "time in units of number of seconds since the epoch",
            "module" : "Tree",
            "name" : "timestamp"
          },
          "name" : "date_created",
          "nullable" : "0"
        }, {
          "!" : "Bio::KBase::KIDL::KBT::StructItem",
          "item_type" : {
            "!" : "Bio::KBase::KIDL::KBT::Scalar",
            "annotations" : { },
            "scalar_type" : "int"
          },
          "name" : "n_rows",
          "nullable" : "0"
        }, {
          "!" : "Bio::KBase::KIDL::KBT::StructItem",
          "item_type" : {
            "!" : "Bio::KBase::KIDL::KBT::Scalar",
            "annotations" : { },
            "scalar_type" : "int"
          },
          "name" : "n_cols",
          "nullable" : "0"
        }, {
          "!" : "Bio::KBase::KIDL::KBT::StructItem",
          "item_type" : {
            "!" : "Bio::KBase::KIDL::KBT::Scalar",
            "annotations" : { },
            "scalar_type" : "string"
          },
          "name" : "alignment_construction_method",
          "nullable" : "0"
        }, {
          "!" : "Bio::KBase::KIDL::KBT::StructItem",
          "item_type" : {
            "!" : "Bio::KBase::KIDL::KBT::Scalar",
            "annotations" : { },
            "scalar_type" : "string"
          },
          "name" : "alignment_construction_parameters",
          "nullable" : "0"
        }, {
          "!" : "Bio::KBase::KIDL::KBT::StructItem",
          "item_type" : {
            "!" : "Bio::KBase::KIDL::KBT::Scalar",
            "annotations" : { },
            "scalar_type" : "string"
          },
          "name" : "alignment_protocol",
          "nullable" : "0"
        }, {
          "!" : "Bio::KBase::KIDL::KBT::StructItem",
          "item_type" : {
            "!" : "Bio::KBase::KIDL::KBT::Scalar",
            "annotations" : { },
            "scalar_type" : "string"
          },
          "name" : "source_db",
          "nullable" : "0"
        }, {
          "!" : "Bio::KBase::KIDL::KBT::StructItem",
          "item_type" : {
            "!" : "Bio::KBase::KIDL::KBT::Scalar",
            "annotations" : { },
            "scalar_type" : "string"
          },
          "name" : "source_id",
          "nullable" : "0"
        } ],
        "module" : "Tree",
        "name" : "alignment_meta_data"
      },
      "annotations" : {
        "metadata" : { },
        "searchable_ws_subset" : { },
        "unknown_annotations" : { }
      },
      "comment" : "Meta data associated with an alignment.\n\n    list<kbase_id> tree_ids - the set of trees that were built from this alignment\n    string status - set to 'active' if this is the latest alignment for a particular set of sequences\n    string sequence_type - indicates what type of sequence is aligned (e.g. protein vs. dna)\n    bool is_concatenation - true if the alignment is based on the concatenation of multiple non-contiguous\n                            sequences, false if each row cooresponds to exactly one sequence (possibly with gaps)\n    timestamp date_created - time at which the alignment was built/loaded in seconds since the epoch\n    int n_rows - number of rows in the alignment\n    int n_cols - number of columns in the alignment\n    string alignment_construction_method - the name of the software tool used to build the alignment\n    string alignment_construction_parameters - set of non-default parameters used to construct the alignment\n    string alignment_protocol - simple free-form text which may provide additional details of how the alignment was built\n    string source_db - the source database where this alignment originated, if one exists\n    string source_id - the id of this alignment in an external database, if one exists",
      "module" : "Tree",
      "name" : "alignment_meta_data"
    },
    "bool" : {
      "!" : "Bio::KBase::KIDL::KBT::Typedef",
      "alias_type" : {
        "!" : "Bio::KBase::KIDL::KBT::Scalar",
        "annotations" : { },
        "scalar_type" : "int"
      },
      "annotations" : {
        "metadata" : { },
        "searchable_ws_subset" : { },
        "unknown_annotations" : { }
      },
      "comment" : "indicates true or false values, false <= 0, true >=1",
      "module" : "Tree",
      "name" : "bool"
    },
    "fasta" : {
      "!" : "Bio::KBase::KIDL::KBT::Typedef",
      "alias_type" : {
        "!" : "Bio::KBase::KIDL::KBT::Scalar",
        "annotations" : { },
        "scalar_type" : "string"
      },
      "annotations" : {
        "metadata" : { },
        "searchable_ws_subset" : { },
        "unknown_annotations" : { }
      },
      "comment" : "String representation of a sequence or set of sequences in FASTA format.  The precise alphabet used is\nnot yet specified, but will be similar to sequences stored in KBase with '-' to denote gaps in alignments.",
      "module" : "Tree",
      "name" : "fasta"
    },
    "fasta_alignment" : {
      "!" : "Bio::KBase::KIDL::KBT::Typedef",
      "alias_type" : {
        "!" : "Bio::KBase::KIDL::KBT::Typedef",
        "alias_type" : {
          "!" : "Bio::KBase::KIDL::KBT::Scalar",
          "annotations" : { },
          "scalar_type" : "string"
        },
        "annotations" : {
          "metadata" : { },
          "searchable_ws_subset" : { },
          "unknown_annotations" : { }
        },
        "comment" : "String representation of a sequence or set of sequences in FASTA format.  The precise alphabet used is\nnot yet specified, but will be similar to sequences stored in KBase with '-' to denote gaps in alignments.",
        "module" : "Tree",
        "name" : "fasta"
      },
      "annotations" : {
        "metadata" : { },
        "searchable_ws_subset" : { },
        "unknown_annotations" : { }
      },
      "comment" : "String representation of an alignment in FASTA format.  The precise alphabet and syntax of the alignment\nstring is not yet specified, but will be similar to sequences stored in KBase  with '-' to denote gaps in\nalignments.",
      "module" : "Tree",
      "name" : "fasta_alignment"
    },
    "float" : {
      "!" : "Bio::KBase::KIDL::KBT::Scalar",
      "annotations" : { },
      "scalar_type" : "float"
    },
    "html_file" : {
      "!" : "Bio::KBase::KIDL::KBT::Typedef",
      "alias_type" : {
        "!" : "Bio::KBase::KIDL::KBT::Scalar",
        "annotations" : { },
        "scalar_type" : "string"
      },
      "annotations" : {
        "metadata" : { },
        "searchable_ws_subset" : { },
        "unknown_annotations" : { }
      },
      "comment" : "String in HTML format, used in the KBase Tree library for returning rendered trees.",
      "module" : "Tree",
      "name" : "html_file"
    },
    "int" : {
      "!" : "Bio::KBase::KIDL::KBT::Scalar",
      "annotations" : { },
      "scalar_type" : "int"
    },
    "json_tree" : {
      "!" : "Bio::KBase::KIDL::KBT::Typedef",
      "alias_type" : {
        "!" : "Bio::KBase::KIDL::KBT::Typedef",
        "alias_type" : {
          "!" : "Bio::KBase::KIDL::KBT::Scalar",
          "annotations" : { },
          "scalar_type" : "string"
        },
        "annotations" : {
          "metadata" : { },
          "searchable_ws_subset" : { },
          "unknown_annotations" : { }
        },
        "comment" : "A string representation of a phylogenetic tree.  The format/syntax of the string is\nspecified by using one of the available typedefs declaring a particular format, such as 'newick_tree',\n'phyloXML_tree' or 'json_tree'.  When a format is not explictily specified, it is possible to return\ntrees in different formats depending on addtional parameters. Regardless of format, all leaf nodes\nin trees built from MSAs are indexed to a specific MSA row.  You can use the appropriate functionality\nof the API to replace these IDs with other KBase Ids instead. Internal nodes may or may not be named.\nNodes, depending on the format, may also be annotated with structured data such as bootstrap values and\ndistances.",
        "module" : "Tree",
        "name" : "tree"
      },
      "annotations" : {
        "metadata" : { },
        "searchable_ws_subset" : { },
        "unknown_annotations" : { }
      },
      "comment" : "Trees are represented in KBase by default in newick format (http://en.wikipedia.org/wiki/Newick_format),\nbut can optionally be converted to JSON format where the structure of the tree matches the structure of\nthe JSON object.  This is useful when interacting with the tree in JavaScript, for instance.",
      "module" : "Tree",
      "name" : "json_tree"
    },
    "kbase_id" : {
      "!" : "Bio::KBase::KIDL::KBT::Typedef",
      "alias_type" : {
        "!" : "Bio::KBase::KIDL::KBT::Scalar",
        "annotations" : { },
        "scalar_type" : "string"
      },
      "annotations" : {
        "metadata" : { },
        "searchable_ws_subset" : { },
        "unknown_annotations" : { }
      },
      "comment" : "A KBase ID is a string starting with the characters \"kb|\".  KBase IDs are typed. The types are\ndesignated using a short string. For instance,\" g\" denotes a genome, \"tree\" denotes a Tree, and\n\"aln\" denotes a sequence alignment. KBase IDs may be hierarchical.  For example, if a KBase genome\nidentifier is \"kb|g.1234\", a protein encoding gene within that genome may be represented as\n\"kb|g.1234.peg.771\".",
      "module" : "Tree",
      "name" : "kbase_id"
    },
    "newick_tree" : {
      "!" : "Bio::KBase::KIDL::KBT::Typedef",
      "alias_type" : {
        "!" : "Bio::KBase::KIDL::KBT::Typedef",
        "alias_type" : {
          "!" : "Bio::KBase::KIDL::KBT::Scalar",
          "annotations" : { },
          "scalar_type" : "string"
        },
        "annotations" : {
          "metadata" : { },
          "searchable_ws_subset" : { },
          "unknown_annotations" : { }
        },
        "comment" : "A string representation of a phylogenetic tree.  The format/syntax of the string is\nspecified by using one of the available typedefs declaring a particular format, such as 'newick_tree',\n'phyloXML_tree' or 'json_tree'.  When a format is not explictily specified, it is possible to return\ntrees in different formats depending on addtional parameters. Regardless of format, all leaf nodes\nin trees built from MSAs are indexed to a specific MSA row.  You can use the appropriate functionality\nof the API to replace these IDs with other KBase Ids instead. Internal nodes may or may not be named.\nNodes, depending on the format, may also be annotated with structured data such as bootstrap values and\ndistances.",
        "module" : "Tree",
        "name" : "tree"
      },
      "annotations" : {
        "metadata" : { },
        "searchable_ws_subset" : { },
        "unknown_annotations" : { }
      },
      "comment" : "Trees are represented in KBase by default in newick format (http://en.wikipedia.org/wiki/Newick_format)\nand are returned to you in this format by default.",
      "module" : "Tree",
      "name" : "newick_tree"
    },
    "node_name" : {
      "!" : "Bio::KBase::KIDL::KBT::Typedef",
      "alias_type" : {
        "!" : "Bio::KBase::KIDL::KBT::Scalar",
        "annotations" : { },
        "scalar_type" : "string"
      },
      "annotations" : {
        "metadata" : { },
        "searchable_ws_subset" : { },
        "unknown_annotations" : { }
      },
      "comment" : "The string representation of the parsed node name (may be a kbase_id, but does not have to be).  Note that this\nis not the full, raw label in a newick_tree (which may include comments).",
      "module" : "Tree",
      "name" : "node_name"
    },
    "phyloXML_tree" : {
      "!" : "Bio::KBase::KIDL::KBT::Typedef",
      "alias_type" : {
        "!" : "Bio::KBase::KIDL::KBT::Typedef",
        "alias_type" : {
          "!" : "Bio::KBase::KIDL::KBT::Scalar",
          "annotations" : { },
          "scalar_type" : "string"
        },
        "annotations" : {
          "metadata" : { },
          "searchable_ws_subset" : { },
          "unknown_annotations" : { }
        },
        "comment" : "A string representation of a phylogenetic tree.  The format/syntax of the string is\nspecified by using one of the available typedefs declaring a particular format, such as 'newick_tree',\n'phyloXML_tree' or 'json_tree'.  When a format is not explictily specified, it is possible to return\ntrees in different formats depending on addtional parameters. Regardless of format, all leaf nodes\nin trees built from MSAs are indexed to a specific MSA row.  You can use the appropriate functionality\nof the API to replace these IDs with other KBase Ids instead. Internal nodes may or may not be named.\nNodes, depending on the format, may also be annotated with structured data such as bootstrap values and\ndistances.",
        "module" : "Tree",
        "name" : "tree"
      },
      "annotations" : {
        "metadata" : { },
        "searchable_ws_subset" : { },
        "unknown_annotations" : { }
      },
      "comment" : "Trees are represented in KBase by default in newick format (http://en.wikipedia.org/wiki/Newick_format),\nbut can optionally be converted to the more verbose phyloXML format, which is useful for compatibility or\nwhen additional information/annotations decorate the tree.",
      "module" : "Tree",
      "name" : "phyloXML_tree"
    },
    "position" : {
      "!" : "Bio::KBase::KIDL::KBT::Typedef",
      "alias_type" : {
        "!" : "Bio::KBase::KIDL::KBT::Scalar",
        "annotations" : { },
        "scalar_type" : "int"
      },
      "annotations" : {
        "metadata" : { },
        "searchable_ws_subset" : { },
        "unknown_annotations" : { }
      },
      "comment" : "integer number indicating a 1-based position in an amino acid / nucleotide sequence",
      "module" : "Tree",
      "name" : "position"
    },
    "string" : {
      "!" : "Bio::KBase::KIDL::KBT::Scalar",
      "annotations" : { },
      "scalar_type" : "string"
    },
    "timestamp" : {
      "!" : "Bio::KBase::KIDL::KBT::Typedef",
      "alias_type" : {
        "!" : "Bio::KBase::KIDL::KBT::Scalar",
        "annotations" : { },
        "scalar_type" : "string"
      },
      "annotations" : {
        "metadata" : { },
        "searchable_ws_subset" : { },
        "unknown_annotations" : { }
      },
      "comment" : "time in units of number of seconds since the epoch",
      "module" : "Tree",
      "name" : "timestamp"
    },
    "tree" : {
      "!" : "Bio::KBase::KIDL::KBT::Typedef",
      "alias_type" : {
        "!" : "Bio::KBase::KIDL::KBT::Scalar",
        "annotations" : { },
        "scalar_type" : "string"
      },
      "annotations" : {
        "metadata" : { },
        "searchable_ws_subset" : { },
        "unknown_annotations" : { }
      },
      "comment" : "A string representation of a phylogenetic tree.  The format/syntax of the string is\nspecified by using one of the available typedefs declaring a particular format, such as 'newick_tree',\n'phyloXML_tree' or 'json_tree'.  When a format is not explictily specified, it is possible to return\ntrees in different formats depending on addtional parameters. Regardless of format, all leaf nodes\nin trees built from MSAs are indexed to a specific MSA row.  You can use the appropriate functionality\nof the API to replace these IDs with other KBase Ids instead. Internal nodes may or may not be named.\nNodes, depending on the format, may also be annotated with structured data such as bootstrap values and\ndistances.",
      "module" : "Tree",
      "name" : "tree"
    },
    "tree_meta_data" : {
      "!" : "Bio::KBase::KIDL::KBT::Typedef",
      "alias_type" : {
        "!" : "Bio::KBase::KIDL::KBT::Struct",
        "annotations" : {
          "metadata" : { },
          "searchable_ws_subset" : { }
        },
        "comment" : "Meta data associated with a tree.\n\n    kbase_id alignment_id - if this tree was built from an alignment, this provides that alignment id\n    string type - the type of tree; possible values currently are \"sequence_alignment\" and \"genome\" for trees\n                  either built from a sequence alignment, or imported directly indexed to genomes.\n    string status - set to 'active' if this is the latest built tree for a particular gene family\n    timestamp date_created - time at which the tree was built/loaded in seconds since the epoch\n    string tree_contruction_method - the name of the software used to construct the tree\n    string tree_construction_parameters - any non-default parameters of the tree construction method\n    string tree_protocol - simple free-form text which may provide additional details of how the tree was built\n    int node_count - total number of nodes in the tree\n    int leaf_count - total number of leaf nodes in the tree (generally this cooresponds to the number of sequences)\n    string source_db - the source database where this tree originated, if one exists\n    string source_id - the id of this tree in an external database, if one exists",
        "items" : [ {
          "!" : "Bio::KBase::KIDL::KBT::StructItem",
          "item_type" : {
            "!" : "Bio::KBase::KIDL::KBT::Typedef",
            "alias_type" : {
              "!" : "Bio::KBase::KIDL::KBT::Scalar",
              "annotations" : { },
              "scalar_type" : "string"
            },
            "annotations" : {
              "metadata" : { },
              "searchable_ws_subset" : { },
              "unknown_annotations" : { }
            },
            "comment" : "A KBase ID is a string starting with the characters \"kb|\".  KBase IDs are typed. The types are\ndesignated using a short string. For instance,\" g\" denotes a genome, \"tree\" denotes a Tree, and\n\"aln\" denotes a sequence alignment. KBase IDs may be hierarchical.  For example, if a KBase genome\nidentifier is \"kb|g.1234\", a protein encoding gene within that genome may be represented as\n\"kb|g.1234.peg.771\".",
            "module" : "Tree",
            "name" : "kbase_id"
          },
          "name" : "alignment_id",
          "nullable" : "0"
        }, {
          "!" : "Bio::KBase::KIDL::KBT::StructItem",
          "item_type" : {
            "!" : "Bio::KBase::KIDL::KBT::Scalar",
            "annotations" : { },
            "scalar_type" : "string"
          },
          "name" : "type",
          "nullable" : "0"
        }, {
          "!" : "Bio::KBase::KIDL::KBT::StructItem",
          "item_type" : {
            "!" : "Bio::KBase::KIDL::KBT::Scalar",
            "annotations" : { },
            "scalar_type" : "string"
          },
          "name" : "status",
          "nullable" : "0"
        }, {
          "!" : "Bio::KBase::KIDL::KBT::StructItem",
          "item_type" : {
            "!" : "Bio::KBase::KIDL::KBT::Typedef",
            "alias_type" : {
              "!" : "Bio::KBase::KIDL::KBT::Scalar",
              "annotations" : { },
              "scalar_type" : "string"
            },
            "annotations" : {
              "metadata" : { },
              "searchable_ws_subset" : { },
              "unknown_annotations" : { }
            },
            "comment" : "time in units of number of seconds since the epoch",
            "module" : "Tree",
            "name" : "timestamp"
          },
          "name" : "date_created",
          "nullable" : "0"
        }, {
          "!" : "Bio::KBase::KIDL::KBT::StructItem",
          "item_type" : {
            "!" : "Bio::KBase::KIDL::KBT::Scalar",
            "annotations" : { },
            "scalar_type" : "string"
          },
          "name" : "tree_contruction_method",
          "nullable" : "0"
        }, {
          "!" : "Bio::KBase::KIDL::KBT::StructItem",
          "item_type" : {
            "!" : "Bio::KBase::KIDL::KBT::Scalar",
            "annotations" : { },
            "scalar_type" : "string"
          },
          "name" : "tree_construction_parameters",
          "nullable" : "0"
        }, {
          "!" : "Bio::KBase::KIDL::KBT::StructItem",
          "item_type" : {
            "!" : "Bio::KBase::KIDL::KBT::Scalar",
            "annotations" : { },
            "scalar_type" : "string"
          },
          "name" : "tree_protocol",
          "nullable" : "0"
        }, {
          "!" : "Bio::KBase::KIDL::KBT::StructItem",
          "item_type" : {
            "!" : "Bio::KBase::KIDL::KBT::Scalar",
            "annotations" : { },
            "scalar_type" : "int"
          },
          "name" : "node_count",
          "nullable" : "0"
        }, {
          "!" : "Bio::KBase::KIDL::KBT::StructItem",
          "item_type" : {
            "!" : "Bio::KBase::KIDL::KBT::Scalar",
            "annotations" : { },
            "scalar_type" : "int"
          },
          "name" : "leaf_count",
          "nullable" : "0"
        }, {
          "!" : "Bio::KBase::KIDL::KBT::StructItem",
          "item_type" : {
            "!" : "Bio::KBase::KIDL::KBT::Scalar",
            "annotations" : { },
            "scalar_type" : "string"
          },
          "name" : "source_db",
          "nullable" : "0"
        }, {
          "!" : "Bio::KBase::KIDL::KBT::StructItem",
          "item_type" : {
            "!" : "Bio::KBase::KIDL::KBT::Scalar",
            "annotations" : { },
            "scalar_type" : "string"
          },
          "name" : "source_id",
          "nullable" : "0"
        } ],
        "module" : "Tree",
        "name" : "tree_meta_data"
      },
      "annotations" : {
        "metadata" : { },
        "searchable_ws_subset" : { },
        "unknown_annotations" : { }
      },
      "comment" : "Meta data associated with a tree.\n\n    kbase_id alignment_id - if this tree was built from an alignment, this provides that alignment id\n    string type - the type of tree; possible values currently are \"sequence_alignment\" and \"genome\" for trees\n                  either built from a sequence alignment, or imported directly indexed to genomes.\n    string status - set to 'active' if this is the latest built tree for a particular gene family\n    timestamp date_created - time at which the tree was built/loaded in seconds since the epoch\n    string tree_contruction_method - the name of the software used to construct the tree\n    string tree_construction_parameters - any non-default parameters of the tree construction method\n    string tree_protocol - simple free-form text which may provide additional details of how the tree was built\n    int node_count - total number of nodes in the tree\n    int leaf_count - total number of leaf nodes in the tree (generally this cooresponds to the number of sequences)\n    string source_db - the source database where this tree originated, if one exists\n    string source_id - the id of this tree in an external database, if one exists",
      "module" : "Tree",
      "name" : "tree_meta_data"
    }
  } ] ]
}